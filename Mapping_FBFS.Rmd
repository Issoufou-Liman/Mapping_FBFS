---
title: "Application of Bayesian networks to mapping Flood-based Farming Systems."
note: "Replication files are available on the author's Github account (http://github.com/Issoufou-Liman)."
author:
  - Issoufou Liman:
      email: issoufoul@gmail.com
      institute: [ICRAF, KU]
      correspondence: true
  - name: Cory Whitney
    institute: [ICRAF, ZEF]
  - name: James Kungu
    institute: [KU]
  - name: Eike Luedeling
    institute: [ICRAF, ZEF, INRES]
institute:
  - ICRAF: World Agroforestry Centre (ICRAF), United Nations Avenue, Gigiri, P. O. Box 30677-00100, Nairobi, Kenya
  - KU: Kenyatta University, Department of Environmental Sciences
  - ZEF: Center for Development research (ZEF), University of Bonn, Genscherallee 3, D-53113, Bonn, Germany
  - INRES: University of Bonn, Department of Horticultural Sciences, Auf dem Hügel 6, D-53121, Bonn, Germany
abstract: "Accurate information on actual areas under given cropping/farming systems is an important input for applied agricultural research and policies. Therein, remote sensing provides a useful tool for analysing spatial metrics in an explicit manner. In this paper, we captured various characteristics of flood-based farming systems (FBFS) with remote sensing and applied a probabilistic framework for system analysis. FBFS were mapped across the Kisumu County in Kenya by incorporating uncertainties into mapping overlays. A Bayesian network ([BNs](https://en.wikipedia.org/wiki/Bayesian_network)) was used to describe and interlink various features of FBFS using expert knowledge. 3 years (2014-2016) of high-level [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) VI products data were acquired in the forms of normalized difference spectral indices (NDSI). These were used as proxies for estimating various metrics of FBFS which were later used to feed the spatial data nodes of the [BNs](https://en.wikipedia.org/wiki/Bayesian_network) and were propagated along with the rest of other non-spatial nodes derived from expert judgement. We demonstrate that spatial explicit information can be derived from remote sensing data as fuzzy linguistic quantifiers which are suitable for representing node states in [BNs](https://en.wikipedia.org/wiki/Bayesian_network). When such metrics are available, [BNs](https://en.wikipedia.org/wiki/Bayesian_network) are useful tools for incorporating uncertainties when mapping complex systems in a context of limited and uncertain information. The causal probabilistic reasoning embedded in the approach was tested on the Tigray region in Ethiopia; an area with totally different settings; and seems to perform incredibly well. Results were transparently generated in forms of intermediary prior spatial maps for specific metrics to ultimately be aggregated into final posterior maps of plausible areas for flood-based farming along with their spatial explicit uncertainties."
fontfamily: mathpazo
fontsize: 12pt
spacing: double
date: "`r format(Sys.time(), '%B %d, %Y')`"
documentclass: article
classoption: oneside # preprint
geometry: margin=1in
linkcolor: blue
urlcolor: blue
citecolor: red
bibliography: ./referencing_files/bibliographie.bib
csl: ./referencing_files/scientific-reports.csl # nature.csl #   elsevier-harvard.csl #  
subparagraph: yes
link-citations: true
header-includes:
   - \usepackage[ruled,vlined,linesnumbered]{algorithm2e}
output: 
  bookdown::pdf_document2: 
    toc: true
    toc_depth: 5
    number_sections: true
    keep_tex: true
    fig_caption: true
    latex_engine: xelatex # pdflatex #  lualatex #
    includes:
      in_header: ./formating_files/inheader_2.tex
    pandoc_args:
      - '--lua-filter=./formating_files/scholarly-metadata.lua'
      - '--lua-filter=./formating_files/author-info-blocks.lua'
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 5
    number_sections: true
    df_print: paged
    keep_tex: true
    fig_caption: true
    latex_engine: xelatex # pdflatex # lualatex #  
    pandoc_args:
      - '--lua-filter=./formating_files/scholarly-metadata.lua'
      - '--lua-filter=./formating_files/author-info-blocks.lua'
  bookdown::word_document2:
    toc: no
    toc_depth: 5
    fig_caption: true
    pandoc_args:
      - '--lua-filter=./formating_files/scholarly-metadata.lua'
      - '--lua-filter=./formating_files/author-info-blocks.lua'
---

```{r, include=FALSE}
options(tinytex.engine = 'xelatex')
pdf.options(useDingbats = TRUE)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra = '',fig.align='center',fig.pos='!htbp',cache=TRUE)
```


```{r Setting the Scene, include = FALSE, echo = FALSE, cache = FALSE}

set.seed(123)
### Installing devtools package to get decisionSupportExtra from github ####
if (!require("devtools")) {
  install.packages("devtools")
}
## Installing decisionSupportExtra SpatialProbs growingSeason and RTauDEM packages from github ####
if (!require("decisionSupportExtra")) {
  devtools::install_github("Issoufou-Liman/decisionSupportExtra", build = TRUE, force = TRUE,
                           upgrade = "always")
}

if (!require("SpatialProbs")) {
  devtools::install_github("Issoufou-Liman/SpatialProbs", build = TRUE, force = TRUE,
                           upgrade = "always")
}

if (!require("growingSeason")) {
  devtools::install_github("Issoufou-Liman/growingSeason", build = TRUE, force = TRUE,
                           upgrade = "always")
}

if (!require("RTauDEM")) {
  devtools::install_github("Issoufou-Liman/RTauDEM", build = TRUE, force = TRUE,
                           upgrade = "always")
}
## loading required packages ####
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rgdal,
               raster,
               MODIStsp,
               ggplot2,
               grid,
               gridExtra,
               caret,
               party,
               decisionSupportExtra,
               SpatialProbs,
               growingSeason,
               xts,
               fields,
               gRain,
               bnlearn,
               bnspatial,
               knitr,
               kableExtra
)
## Loading decisionSupportExtra package ####
library(decisionSupportExtra)
library(growingSeason)
library(SpatialProbs)
library(RTauDEM)

## exporting the plot to file.####
export_fun <- function(export, output_dir = "figures"){
  paste0(output_dir, '/', export, ".png")
}

my_theme <- theme_minimal() +
  theme(text = element_text(family = 'serif', face = 'plain'),
        panel.spacing=unit(0.075, "lines"),
        panel.border = element_rect(color = "lightgrey", fill = NA, size = 0.5),
        #axis.text = element_text(size=7),
        axis.ticks = element_line(colour = 'black', size = 0.05),
        legend.title = element_blank(),
        legend.text = element_text(size=12, face="bold", color="black"),
        legend.position="top",
        legend.justification = 'right',
        legend.margin=margin(0, 0, 0, 0),
        legend.box.margin=margin(-22, 0, -10, 0),
        strip.background = element_rect(color = "gray", size = 0.075),
        strip.text = element_text(size=12, face="bold", color="black"),
        axis.text = element_text(size=12, color="black"),
        plot.title=element_text(size=14, face="bold", color="black"),
        plot.subtitle=element_text(size=12, face="italic", color="blue")
  )

ifelse(!dir.exists(file.path(getwd(), 'data_files/hdf')), dir.create(file.path(getwd(), 'data_files/hdf')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'data_files/ndsi')), dir.create(file.path(getwd(), 'data_files/ndsi')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'data_files/shapefiles')), dir.create(file.path(getwd(), 'data_files/shapefiles')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'modis_opts')), dir.create(file.path(getwd(), 'modis_opts')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'figures')), dir.create(file.path(getwd(), 'figures')), FALSE)
# ifelse(!dir.exists(file.path(getwd(), 'data_files')), dir.create(file.path(getwd(), 'data_files')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'data_files/dem')), dir.create(file.path(getwd(), 'data_files/dem')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'data_files/dem/Kisumu')), dir.create(file.path(getwd(), 'dem/Kisumu')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'data_files/dem/Tigray')), dir.create(file.path(getwd(), 'dem/Tigray')), FALSE)
ifelse(!dir.exists(file.path(getwd(), 'output_files')), dir.create(file.path(getwd(), 'output_files')), FALSE)

# col = rev(terrain.colors(255)) 
col = c('#FF4500', '#FFA07A','#FFE4E1', '#FFDEAD', '#808000', '#6B8E23')
col = c('#FF4500', '#FFA07A','#FFE4E1', '#FFDEAD', '#808000', '#008000')

# col = c('#ADD8E6', '#F8F8FF', '#EEE8AA', '#F4A460', '#90EE90', '#228B22')
# col = c('#ADD8E6', '#E0FFFF', '#EEE8AA', '#F4A460', '#90EE90', '#228B22')
# col = c('#ADD8E6', '#E0FFFF',  '#F8F8FF', '#EEE8AA','#90EE90', '#228B22')
```

```{r Data acquisition and preprocessing, include = FALSE, echo = FALSE, cache = FALSE}
Kenya_L1 <- getData("GADM", country="ken", level=1, path = 'data_files/shapefiles')
Kisumu <- Kenya_L1 [Kenya_L1$NAME_1 == "Kisumu", ]
writeOGR(Kisumu, 'data_files/shapefiles/', "Kisumu", driver="ESRI Shapefile", overwrite_layer=TRUE)

Ethiopia_L1 <- getData("GADM", country="eth", level=1, path = 'data_files/shapefiles')
Tigray <- Ethiopia_L1 [Ethiopia_L1$NAME_1 == "Tigray", ]
writeOGR(Tigray, 'data_files/shapefiles/', "Tigray", driver="ESRI Shapefile", overwrite_layer=TRUE)

opts_file <- 'modis_opts/modistsp_opts.json'
# opts_file <- "C:/Users/LIssoufou/Documents/Papers/ICRAF/190912_papers/modis_opts/modis_opts.json"

shp_files <- list("data_files/shapefiles/Kisumu.shp", "data_files/shapefiles/Tigray.shp")

for(i in shp_files) {
  MODIStsp(gui = FALSE, options_file = opts_file, spatial_file_path = i)
}

```

```{r Kisumu data fetching and gap filling, include = FALSE, echo = FALSE, cache = FALSE}

beginCluster(n=10)

f <- function(x) {
  x[x < -10000] <- NA
  x[x > 10000] <- NA
  chillR::interpolate_gaps(x)$interp
}

ndvi_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDVI/MOD09A1_NDVI_1_2014_361_2016_RData.RData"
ndvi_ts <-get(load(ndvi_ts))
noms <- getZ(ndvi_ts)
# ndvi_ts <- calc(ndvi_ts, fun = f)
ndvi_ts <- clusterR(x=ndvi_ts, fun = calc, args = list(fun=f))
names(ndvi_ts) <- noms

GAO_NDWI_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/Gao NDWI/MOD09A1_Gao NDWI_1_2014_361_2016_RData.RData"
GAO_NDWI_ts <-get(load(GAO_NDWI_ts))
noms <- getZ(GAO_NDWI_ts)
# GAO_NDWI_ts <- calc(GAO_NDWI_ts, fun = f)
GAO_NDWI_ts <- clusterR(x=GAO_NDWI_ts, fun = calc, args = list(fun=f))
names(GAO_NDWI_ts) <- noms


mcfeeters_NDMI_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/Mcfeeters_NDWI/MOD09A1_Mcfeeters_NDWI_1_2014_361_2016_RData.RData"
mcfeeters_NDMI_ts <-get(load(mcfeeters_NDMI_ts))
noms <- getZ(mcfeeters_NDMI_ts)
# mcfeeters_NDMI_ts <- calc(mcfeeters_NDMI_ts, fun = f)
mcfeeters_NDMI_ts <- clusterR(x=mcfeeters_NDMI_ts, fun = calc, args = list(fun=f))
names(mcfeeters_NDMI_ts) <- noms


Boschetti_NDFI_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDFI/MOD09A1_NDFI_1_2014_361_2016_RData.RData"
Boschetti_NDFI_ts <-get(load(Boschetti_NDFI_ts))
noms <- getZ(Boschetti_NDFI_ts)
# Boschetti_NDFI_ts <- calc(Boschetti_NDFI_ts, fun = f)
Boschetti_NDFI_ts <- clusterR(x=Boschetti_NDFI_ts, fun = calc, args = list(fun=f))
names(Boschetti_NDFI_ts) <- noms

ndii6_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDII6/MOD09A1_NDII6_1_2014_361_2016_RData.RData"
ndii6_ts <-get(load(ndii6_ts))
noms <- getZ(ndii6_ts)
# ndii6_ts <- calc(ndii6_ts, fun = f)
ndii6_ts <- clusterR(x=ndii6_ts, fun = calc, args = list(fun=f))
names(ndii6_ts) <- noms

ndii7_ts <- "data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDII7/MOD09A1_NDII7_1_2014_361_2016_RData.RData"
ndii7_ts <-get(load(ndii7_ts))
noms <- getZ(ndii7_ts)
# ndii7_ts <- calc(ndii7_ts, fun = f)
ndii7_ts <- clusterR(x=ndii7_ts, fun = calc, args = list(fun=f))
names(ndii7_ts) <- noms


p_tools <-"data_files/ndsi/Kisumu/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/QA_bits/MOD09A1_QA_bits_1_2014_361_2016_RData.RData"
p_tools <-get(load(p_tools))
# p_tools <- calc(p_tools, fun = function(x) {
#   out <- length(x[x==0])/length(x)
#   ifelse(out==1, 1, 0)
# })
f <- function(x) {
  out <- length(x[x==0])/length(x)
  ifelse(out==1, 1, 0)
}
p_tools <- clusterR(x=p_tools, fun = calc, args = list(fun=f))
```
# Introduction {#intro}

Flood-based farming systems (FBFS) are rainfed farming systems occurring in drylands areas and receiving extra irrigation from various type of non-harmful floods that share the properties of being unpredictable, of short duration, of low annual frequency and occurring in relatively lowlands areas with gentile local topography where various social and institutional arrangements govern the water access and sharing [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010; @Varisco_1983]. By making flood water available for use in agriculture, these farming systems contribute to food security along with many other benefits for drylands’ society [@VanSteenbergen_et_al_2010; @Xing_et_al_2014]. They are mostly extensive subsistence-based but support millions of farmers especially in East Africa where they also provide income and various other intangible services [@Puertas_et_al_2011]. Many countries across Africa and Asia endorsed their development through a common framework for research, policy and action (i.e. Flood-based Livelihood Network (FBLN) foundation) mandated for knowledge sharing, filling critical knowledge gaps and improving their productivity of these farming systems [@FBLN_2018; @Puertas_et_al_2011].

Despite their promises and importance,  FBFS have been the topic of surprisingly few studies [@VanSteenbergen_et_al_2010] focusing on aspects related to hydrology and sedimentation, design and maintenance, or sociology attuned to specific contexts [@Haile_2010; @VanSteenbergen_et_al_2010]. Consequently, there is a general lack of information to answer relevant questions for FBLN countries. For example, little effort has been made to provide reliable estimates of their coverage [@VanSteenbergen_et_al_2010].  Despite the existing country-specific area estimates, it is often unclear how these were derived resulting in large uncertainties across these estimates [@VanSteenbergen_et_al_2010]. Most FBLN countries’ reports expressed the need for mapping FBFS, yet only few attempts [e.g. @Ghebreamlak_et_al_2018; @Khalid_et_al_2016; @Theilen-Willige_et_al_2015] are available towards this end in our knowledge. While most aspects related to FBFS are unpredictable [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010], these approaches seems to rely on the assumption that agronomic flooding can be clearly detected on a satellite image in the near time of flooding event and sometimes imply that the areas to be mapped and the timing of the flooding is already known and matches a remote sensing scene in space and time. Furthermore, some of these approaches rely on the derivation of some kind of thresholds based on which FBFS can be discriminated. Threshold-based methods may be impractical considering the complexity of FBFS, the communalities they share with both forests, open water, rainfed and irrigated systems [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010], and particularly when discriminating between different type of FBFS [@Boschetti_et_al_2014]. Moreover, some of these methods rely on visual interpretations which are hard to upscale and may require a keen knowledge of the area. While it is challenging to map these FBFS, accurate information is needed to monitor them, assess their contribution to food security, biodiversity conservation and other intangible benefits at various scales, urging the need for standard methodologies for mapping them. We argue such a surveillance can be best achieved using Geoinformation.

@Wegmann_et_al_2016 covered a range of capabilities and applications of remote sensing in development research, including the use of spectral vegetation indices, and digital elevation models in ecological studies which have potentials in mapping FBFS. Even though satellite remote sensing provides a framework for comprehensive mapping of these farming systems [@Konecny_2014; @Wegmann_et_al_2016], traditional methods may fail to discriminate them due to their complexity and diversity across different settings [@Boschetti_et_al_2014]. The complexity arises from their similarities with both rainfed and irrigated systems [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010] along with a number of their biophysical attributes that could exhibit different signatures and can, therefore, only provide partial information for discriminating them. In flood-based agriculture, one may expect, for instance, an open water followed by rapid increase in vegetation or a combination of thereof [@Boschetti_et_al_2014]. The sequence open water-vegetation, though, can be misleading because the flood event can take place without leaving detectable trace of inundation not only because the sensor can miss to capture the flood event but also because many FBFS have deep soils capable of storing large amount of water. The flood event may also occur after the planting date in which case it can be confused with other flood hazards. The diversity of flood-based agriculture may pose another challenge for mapping FBFS because locally adopted thresholds may be required [@Bashari_et_al_2008] due to the diversity of conditions under which they are practiced [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010]. In addition, the areas under the practice may be unstable over time because of changes in the water courses, water flow, etc. [@VanSteenbergen_et_al_2010]. There is clearly a need for generic approaches for mapping FBFS which can be applied to several contexts given their diversity and the diversity of crops grown under them [@Puertas_et_al_2011].

Mapping such complex systems, where events can be causally related in a context of data uncertainty may require multivariate approaches that are able to leverage on both available information and expertise [@Hubbard_2014; @Kuhnert_et_al_2010; @Kuhnert_et_al_2005; @Whitney_et_al_2018]. Considering the data uncertainty for remote sensing of FBFS, Such an approach, conversely, needs to be able to combine knowledge from domain experts with learning from all available data, be suitable for incomplete information while accounting for the sources of uncertainties [@Kuhnert_2011; @Luedeling_et_al_2015; @Whitney_et_al_2018a]. These expectations can be achieved using [BNs](https://en.wikipedia.org/wiki/Bayesian_network)  [@Whitney_et_al_2018a; @Yet_et_al_2016]. The technicalities along with the many real-world applications of [BNs](https://en.wikipedia.org/wiki/Bayesian_network) are beyond the scope of this paper and are extensively documented elsewhere [see @Pourret_et_al_2008].

The objective of this paper is to provide an affordable mapping routine that could be used to comprehensively estimate the coverage of FBFS. However, the concept is reproducible in other contexts where spatial data are available. Based on the definition and characteristics of FBFS [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010; @VanSteenbergen_et_al_2011 see also paragraph 1], examining a number of biophysical surface states related to their characteristic hydrology, vegetation, and topography, preferably in forms of time series where possible, are clearly relevant for mapping them. With this assumption, we used open source satellite remote sensing data and software to capture various FBFS attributes following a conceptual model developed by experts using various normalized difference spectral indices (NDSI) and topographic structures [@Arge_et_al_2003; @Gao_1996; @Hunt_and_Rock_1989; @Jenson_and_Domingue_1988; @Ji_et_al_2009; @McFeeters_1996; @Rouse_et_al_1973; @Roy_et_al_2014; @Tarboton_2003; @Tucker_1979; @Wegmann_et_al_2016; @Yang_et_al_2006] specific to FBFS to ultimately derive their probability of occurrence for each pixel across Kisumu County in Kenya. We argue that threshold-based methods may be unsuitable to mapping such complex systems and demonstrate the versatility of probabilistic methods. Despite the ranges of data uncertainty under such complex systems, we elaborate on the existence of some sort of spatio-temporal pattern in the general landscape that can be described using causality and from which fuzzy metrics can be derived to describe distinctives sub-entities. We described how this can be achieved and by deriving the required inputs for [BNs](https://en.wikipedia.org/wiki/Bayesian_network) from raw spatial data. The approach was tested across the Tigray region in Ethiopia (not presented here); an area with different settings; and seems to perform incredibly well. The core data used in the study include three years (2014-2016) of high-level Moderate Resolution Imaging Spectroradiometer ([MODIS](https://terra.nasa.gov/about/terra-instruments/modis)) version VI products acquired in the forms of NDSI, the Shuttle Radar Topographic Mission (STRM) [void-filled Digital Elevation Model](http://srtm.csi.cgiar.org/) (DEM). Data analysis were conducted using the [`R`](https://cran.r-project.org/) programming language [@RCoreTeam_2018] and software packages are referred to as such unless otherwise specified. 

# Material and methods {#I}

## Conceptual framework

```{tikz fig1, echo=FALSE, fig.cap = "Concetual framework for mapping FBFS.", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of conceptual framework %%%%

\begin{tikzpicture}[node distance = 0.5cm]

\node[BnsMultipartStyle, text width = 10cm, align=left, draw=gray, inner sep = 5pt] (GDAM){
\nodepart{one}
{\centering\Huge
   Geo-localisation of the area of interest \par
}
\nodepart{two}
\begin{itemize}\huge
    \item GDAM shapefile acquisition
\end{itemize}
 
};

\node[BnsMultipartStyle, text width = 10cm, align=left, draw=gray, inner sep = 5pt] [below right=of GDAM](modistsp){
\nodepart{one}
{\centering\Huge
   Automatic acquisition of MODIS and SRTM data \par
}
\nodepart{two}
\begin{itemize}
    \item \huge acquisition of MODIS hdf files
    \item \huge GDAL translation of the hdf files
\end{itemize}
 
};



\node[BnsMultipartStyle, text width = 10cm, align=left, draw=gray, inner sep = 5pt] [above right=of modistsp](modis){
\nodepart{one}
{\centering\Huge
  Identification of MODIS tiles \par
}
\nodepart{two}
\begin{itemize}\huge
    \item identification of MODIS tiles
\end{itemize}
 
};

\node[text = blue][below left=of modistsp.south west](derivationofspatialdatanodestitle){\Huge Derivation of spatial data nodes};

\node[BnsMultipartStyle, text width = 8cm, align=left, draw=gray, inner sep = 5pt] [below=of derivationofspatialdatanodestitle](datadiscretisation){
\nodepart{one}
{\centering\Huge
   Data discretisation \par
}
\nodepart{two}
\begin{itemize}\huge
    \item derivation of ranges and discrete states
    \item generation of reclassification matrix
\end{itemize}
 
};

%\node[fill=white, draw=white, text=red][below left=of datadiscretisation](multilayertitle) {\Huge Multi layer procedure};
\node[text=red][below left=of datadiscretisation.south](multilayertitle) {\Huge Multi layer procedure};

%\node[fill=white, draw=white, text=red][below right=of datadiscretisation](singlelayertitle) {\Huge Single layer procedure};
\node[text=red][below right=of datadiscretisation.south](singlelayertitle) {\Huge Single layer procedure};

%\node[BnsMultipartStyle, text width = 8cm, align=left] [below=of multilayertitle](presenceabsence){
%\nodepart{one}
%{\centering
 %  Generation of presence absence data \par
%}
%\nodepart{two}
%};

\node[fill=white, text width = 7cm, align=center, draw=gray, inner sep = 5pt][below=of multilayertitle](presenceabsence){\huge Pixel separation using presence/absence rules};

%\node[BnsMultipartStyle, text width = 8cm, align=left] [below=of presenceabsence](probabilityofdiscreteranges){
%\nodepart{one}
%{\centering
%   Probability of discrete ranges \par
%}
%\nodepart{two}
%};
\node[fill=white, text width = 7cm, align=center, draw=gray, inner sep = 5pt][below=of presenceabsence](probabilityofdiscreteranges){\huge Computation of states probability};


%\node[BnsMultipartStyle, text width = 8cm, align=left] [below=of probabilityofdiscreteranges](confusionpixel){
%\nodepart{one}
%{\centering
%   Confusing pixel heuristics \par
%}
%\nodepart{two}
%};
\node[fill=white, text width = 7cm, align=center, draw=gray, inner sep = 5pt][below=of probabilityofdiscreteranges](confusionpixel){\huge Separation of confusing pixel using heuristic rules};

%\node(fake0) [draw=none, fill=none] [below = 0mm of confusionpixel.south]{};
\node(fake0) [draw=none, fill=none] [below=0cm of confusionpixel.south] {};




%\tcbsetmacrotoheightofnode{\myheight}{multilayerprocedure}

%\node[BnsMultipartStyle, text width = 8cm, align=left] at (probabilityofdiscreteranges-|singlelayertitle) %(reclassification){
%\nodepart{one}
%{\centering
%   Reclassification \par
%}
%\nodepart{two}
%};
\node[fill=white, text width = 5cm, align=center, draw=gray, inner sep = 30pt] at (probabilityofdiscreteranges-|singlelayertitle) (reclassification){\huge Reclassification};

%\node(fake1) [draw=none, fill=none] at (confusionpixel.south-|singlelayertitle){};
\node(fake1) [draw=none, fill=none] at (fake0-|singlelayertitle){};



%\node [BnsStyle, text width=5.28cm] (soilandwater) at (datadiscretisation-|modis) {
%\node [BnsStyle, text width=5.28cm] (soilandwater) [below right=of modistsp.south west] {
%\node [BnsStyle, text width=5.28cm] (soilandwater) at (datadiscretisation-|modis.south west) {
\node [BnsStyle, draw=gray, text width=6cm] (soilandwater) at (datadiscretisation-|modistsp.south east) {
  \begin{varwidth}{\textwidth}
  \begin{center}\Huge
  Soil and water 
  \end{center}
  \begin {BlackBnsBullets}\huge
  \item sensitivity to flood
  \item soil water
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node [BnsStyle, draw=gray, text width=6cm] (topographiccharacteristics)[right=of soilandwater] {
  \begin{varwidth}{\textwidth}
  \begin{center}\Huge
  Topography
  \end{center}
  \begin {BlackBnsBullets}\huge
  \item slope
  \item flow accumulation 
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node [BnsStyle, text width=2.1cm, align=center, draw=red, text=red] (pixelisfbfs)[below left=of topographiccharacteristics] {
  \begin{varwidth}{\textwidth}
  \begin{center}
   \Huge Pixel is FBFS
  \end{center}
  \end{varwidth}
};

\node [BnsStyle, text width=7.70cm, draw=gray] (vegetation)[below=of pixelisfbfs] {
  \begin{varwidth}{\textwidth}
  \begin{center}
   \Huge Vegetation
  \end{center}
  \begin {BlackBnsBullets}\huge
  \item characteristic vegetation
  \item variation in vegetation 
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[text = blue] at (derivationofspatialdatanodestitle-|pixelisfbfs) (bnstitle) {\Huge Expert system based on Bayesian networks};



\node (fake3) at ($(derivationofspatialdatanodestitle.south east)!0.5!(bnstitle.south west)$) {};

%\node (spatiallyexplicitdecisionsupporttool)[draw=black, fill=white, inner sep=10pt][below= 15.50cm of fake3-|modistsp]{\Huge Spatially explicit decision support tool};

\node[BnsMultipartStyle, text width = 10cm, align=left, draw=gray, inner sep = 5pt] [below= 15.50cm of fake3-|modistsp](spatiallyexplicitdecisionsupporttool){
\nodepart{one}
{\centering\Huge
   Hybrid decision support tool \par
}
\nodepart{two}
\begin{itemize}\huge
    \item spatial data component
    \item non-spatial data component 
\end{itemize}
 
};


\node (maps) [draw=none, fill=none, text =blue][below=0.75cm of spatiallyexplicitdecisionsupporttool] {\Huge Spatially explicit causal predictions and maps};

\node (spatiallyexplicituncertainity) [draw=white, fill=white, text width = 4cm, align=center, draw=gray, inner sep = 5pt][below right=of maps] {\huge Uncertainity maps};

\node (probabilisticmaps)[draw=white, fill=white, text width = 4cm, align=center, draw=gray, inner sep = 5pt][below left=of maps]{\huge Probabilistic maps};

\node[draw=none, fill=none][left=of multilayertitle.west](fake5){};
\node[draw=none, fill=none][above=of GDAM.north](fake6){};
\node[draw=none, fill=none][below=of probabilisticmaps.south](fake7){};
\node[draw=none, fill=none][right=of topographiccharacteristics.east](fake8){};


\begin{scope}[on background layer]
\node (backgrounding)[BnsBox, fit=(fake5)(fake6)(fake7)(fake8)] {};
\end{scope}
\node(fake9) [draw=none, fill=none] at (fake0-|singlelayertitle.east){};

\begin{scope}[on background layer]
\node (singlelayerprocedure)[BnsBox, draw=blue, fill=white, opacity=0.5, fit=(reclassification)(singlelayertitle)(fake1)] {};
\end{scope}

\begin{scope}[on background layer]
\node (multilayerprocedure)[BnsBox,  draw=blue, fill=white, opacity=0.5, fit=(multilayertitle)(confusionpixel)(probabilityofdiscreteranges)(presenceabsence)(fake0)] {};
\end{scope}

\begin{scope}[on background layer]
\node (derivationofspatialdatanodes)[BnsBox, draw=black, fill=blue, fill opacity=0.1, fit=(multilayerprocedure)(singlelayertitle)(datadiscretisation)(derivationofspatialdatanodestitle)(fake9)] {};
\end{scope}

\node[draw=none, fill=none] at (fake1.south-|pixelisfbfs)(fake4){};

%\tcbsetmacrotowidthofnode{\mywidth}{derivationofspatialdatanodes}

\begin{scope}[on background layer]
\node (bayesiannetworks)[BnsBox,  draw=black, fill=blue, fill opacity=0.1, fit=(pixelisfbfs)(topographiccharacteristics)(soilandwater)(vegetation)(bnstitle)(fake4)] {};
\end{scope}

\begin{scope}[on background layer]
\node (output)[BnsBox, draw=black, fill=blue, fill opacity=0.1, fit=(probabilisticmaps)(spatiallyexplicituncertainity)(maps)] {};
\end{scope}

\draw[thickarrow] (GDAM) -- (modistsp);
\draw[dashedarrow] (GDAM) -- (modis);
\draw[dashedarrow] (modis) -- (modistsp);

\draw[thickes] (modistsp.west) -- (modistsp.west-|derivationofspatialdatanodes);
\draw[thickarrow] (modistsp.west-|derivationofspatialdatanodes) -- (derivationofspatialdatanodes);

\draw[thickes] (modistsp.east) -- (modistsp.east-|bayesiannetworks);
\draw[thickarrow] (modistsp.east-|bayesiannetworks) -- (bayesiannetworks);

\draw[thickes] (datadiscretisation.west) -- ([xshift = -1cm]datadiscretisation.west-|multilayerprocedure);
\draw[thickarrow] ([xshift = -1cm]datadiscretisation.west-|multilayerprocedure) -- ([xshift = -1cm]multilayerprocedure.north);

\draw[thickes] (datadiscretisation.east) -- ([xshift = 1cm]datadiscretisation.east-|singlelayerprocedure);
\draw[thickarrow] ([xshift = 1cm]datadiscretisation.east-|singlelayerprocedure) -- ([xshift = 1cm]singlelayerprocedure.north);

\draw[thickarrow](presenceabsence)--(probabilityofdiscreteranges);
\draw[thickarrow](probabilityofdiscreteranges)--(confusionpixel);

\draw[thickarrow](soilandwater)--(pixelisfbfs);
\draw[thickarrow](vegetation)--(pixelisfbfs);
\draw[thickarrow](topographiccharacteristics)--(pixelisfbfs);

\draw[thickes] (bayesiannetworks.south) -- (bayesiannetworks.south|-spatiallyexplicitdecisionsupporttool);
\draw[thickarrow] (bayesiannetworks.south|-spatiallyexplicitdecisionsupporttool) -- (spatiallyexplicitdecisionsupporttool.east);

\draw[thickes] (derivationofspatialdatanodes.south) -- (derivationofspatialdatanodes.south|-spatiallyexplicitdecisionsupporttool);
\draw[thickarrow] (derivationofspatialdatanodes.south|-spatiallyexplicitdecisionsupporttool) -- (spatiallyexplicitdecisionsupporttool.west);

\draw[thickarrow](spatiallyexplicitdecisionsupporttool) -- (output);

\draw[dashedarrow] ([yshift=2mm]probabilisticmaps.east) -- ([yshift=2mm]spatiallyexplicituncertainity.west); 
\draw[dashedarrow] ([yshift=-2mm]spatiallyexplicituncertainity.west) -- ([yshift=-2mm]probabilisticmaps.east); 

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);
\end{tikzpicture}
%% End of conceptual framework %%%%
```

## Study area {#I1}

The study took place in two regions of Kenya and Ethiopia, the Kisumu county and the Tigray region respectively. Both areas have long history in terms of the practice of flood-based agriculture and have different ways of managing agronomic flooding. However, this paper specifically focuses on the case of Kisumu to provide the backbones of the methodology. Kisumu is one of the largest of Kenya’s counties, located in the western Kenya [@KisumuCountyGovernment_2013]. It is bordered by the Homa Bay County to the South, Nandi County to the North East, Kericho County to the East, Vihiga County to the North West and Siaya County to the West. Kisumu County extends between 33° 20’E and 35° 20’E and 0° 20’S and 0° 50’S covering an area of 2576.5 km2 of which 567 km2 (4.5%) is covered by water [@KisumuCountyGovernment_2013]. Common topographic features are the Winam Gulf of Lake Victoria and the Rift valley. The central part of the county is relatively flat lands surrounded by higher altitudinal ridges reaching up to 1835 m. The relief of the county can be described by 3 main topographical features, the Kano lowlands plains, the Maseno midlands, and the highlands of Nyabondo Plateau making most of the central part prone to flooding, particularly during periods of heavy rains [@KisumuCountyGovernment_2013]. Kisumu county is endowed in surface water with three main rivers flowing into Lake Victoria [@KisumuCountyGovernment_2013]. The floodplains are good for agriculture due to their relatively rich soils resulting from recurrent alluvial deposits and potential for irrigation. 

## Sensor Characteristics {#I2}

### SRTM {#I21}

[SRTM](https://www2.jpl.nasa.gov/srtm/) is an collaborative project between the US National Aeronautics and Space Administration (NASA) and the National Imagery and Mapping Agency (NIMA), the National Geospatial-Intelligence Agency, and the German and Italian Space Agencies providing the most complete highest resolution and public domain DEM between 56° S and  60° N [@Farr_et_al_2000; @Farr_et_al_2007; @Nikolakopoulos_et_al_2006]. It uses a dual radar antennas interferometry to produce high resolution topographic data and carries over 300 high-density tapes storing these data. several spatial resolutions (e.g. 30m, 90m, 1000m) are available [@Farr_et_al_2007; @Jarvis_et_al_2008]. A list of available [SRTM](https://www2.jpl.nasa.gov/srtm/) data and their sources along with various other information can be found in Farr et al. [-@Farr_et_al_2007] and the accuracy of the [SRTM](https://www2.jpl.nasa.gov/srtm/) data is extensively discussed in Falorni et al. [-@Falorni_et_al_2005]. In this study, we used the 30 m spatial resolution DEM on which further processing were applied to ultimately compute the spatial data nodes used in the [BNs](https://en.wikipedia.org/wiki/Bayesian_network).

### MODIS {#I22}

[MODIS](https://terra.nasa.gov/about/terra-instruments/modis) is a key remote sensing sensor on both Earth Observing System (EOS)-AM1 and EOS-PM1 operating onboard Terra and Aqua satellites respectively [@King_et_al_1995]. [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) acquires data in the visible and infrared regions of the electromagnetic spectrum to provide 36 spectral bands with a viewing swath width of 2,330 km for studying various aspects of terrestrial ecosystems. [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) scenes are geo-localised using a sinusoidal projection system and therefore identified using their specific horizontal (h) and vertical (v) tiles number. These data are provided in different spatial (250 m, 500 m, and 1 Km) and temporal (e.g. daily, 8 days, 16 days) resolutions. In this study, we used the [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) product `MOD09A1` (Terra Surface Reflectance 8-Day L3 Global 500m SIN Grid V006 [@Vermote_2015] which provides an 8-day composite atmospherically corrected land surface reflectance across bands 1 to 7 along with other additional quality indicators layers assessing the quality of the acquisition at pixel level.

## Data acquisition and pre-processing {#I3}

### The BNs {#I31}

[BNs](https://en.wikipedia.org/wiki/Bayesian_network) are reasoning engine and knowledge engineering tools that can be used to model partially known events in forms of probability, incorporate causal uncertainty in the analysis [@Pourret_et_al_2008], and therefore allow reasoning under uncertainty. On the one hand, they are causal probabilistic models, on the other hand, they are ways of decomposing large joint probability distributions [@Pearl_2000; @Pourret_et_al_2008] and specifying complex heuristics that go beyond a simple regression model [@Whitney_et_al_2018]. In Bayesian analysis, scientific reasoning starts with the current state of knowledge and subsequently assesses the contribution of further new information to that knowledge [@Pearl_2000]. [BNs](https://en.wikipedia.org/wiki/Bayesian_network) become more exciting and have proven to give incredibly remarkable results when there is a need to incorporate many variables in a model and determine their effects on an outcome.

In this study, the ultimate outcome variable (`PixelIsFBFS`) determining whether a given pixel qualify for FBFS is described using causal relationships among several other variables specified in a [BNs](https://en.wikipedia.org/wiki/Bayesian_network) model (Figure \@ref(fig:fig1)). The conceptual model described pixels’ potential for FBFS (`PixelIsFBFS`) to be jointly defined by the amount of flood water received (`FloodSomePts`), the topographic suitability, and the extent of vegetation variation due to flood (`VegVarFlood`) at that pixel. A pixel may record important run-on without experiencing flood because the water may run-off without a suitable topography (`suiteTopo`). This is, vegetation variation in space and time can be due to either flood or non-flood water but each pixel can be profiled in terms of its amount of flood water.

```{tikz fig2, echo=FALSE, fig.cap = "Bayesian Network describing the causal reasoning used for mapping FBFS in Kisumu, Kenya.", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Mapping BNs %%%%

\begin{tikzpicture}[node distance = 2.5cm and 2cm]

\node[BnsBarplotStyle] (VegVar2Water1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates {(0.200,Very low)(0.200,Low)(0.200,Medium)(0.200,High)(0.200,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{VegVar2Water1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth, text width=7cm, align=center, inner sep = 2mm](VegVar2Water2)[above=0pt of VegVar2Water1]{Vegetation sensitivity to water variation};

%%%%
\node[BnsBarplotStyle, right= of VegVar2Water1] (Slope1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very steep,Steep,Gentile,Relatively flat,Flat}
                  ]

\addplot [AddPlotStyle]  coordinates {(0.200,Very steep)(0.200,Steep)(0.200,Gentile)(0.200,Relatively flat)(0.200,Flat)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{Slope1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](Slope2)[above=0pt of Slope1]{Slope};

%%%%

%%%%

\node[BnsBarplotStyle, right= of Slope1] (FlowAcc1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates {(0.200,Very low)(0.200,Low)(0.200,Medium)(0.200,High)(0.200,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{FlowAcc1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth, align=center, inner sep = 2mm](FlowAcc2)[above=0pt of FlowAcc1]{Flow\\accumulation};

%%%%

%%%%

\node[BnsBarplotStyle, below=of FlowAcc1] (FloodBgs1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Unexpected,Unusual,Common,Frequent,Permanent}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.200,Unexpected)(0.200,Unusual)(0.200,Common)(0.200,Frequent)(0.200,Permanent)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{FloodBgs1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth, text width = 7cm, align=center, inner sep = 2mm](FloodBgs2)[above=0pt of FloodBgs1]{Flood at the beginning\\ of the growing season};

%%%%

%%%%

\node[BnsBarplotStyle] at (FloodBgs1-|Slope1) (SuiteTopo1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Unsuitable,Suitable}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.709,Unsuitable)(0.291,Suitable)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{SuiteTopo1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](SuiteTopo2)[above=0pt of SuiteTopo1]{Suitable topography};

%%%%

%%%%

\node[BnsBarplotStyle] at (SuiteTopo1-|VegVar2Water1) (CharctVeg1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Dry,Dehydrated, Moderately hydrated,Hydrated,Waterlogged}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.293,Dry)(0.155,Dehydrated)(0.105,Moderately hydrated)(0.154,Hydrated)(0.293,Waterlogged)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{CharctVeg1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth, text width =5cm, align=center, inner sep = 2mm](CharctVeg2)[above=0pt of CharctVeg1]{Characteristic vegetation};

%%%%

%%%%

\node[BnsBarplotStyle, below= of CharctVeg1] (FloodSomePts1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.185,Very low)(0.179,Low)(0.175,Medium)(0.224,High)(0.237,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{FloodSomePts1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](FloodSomePts2)[above=0pt of FloodSomePts1]{Flooded at some point};

%%%%

%%%%

\node[BnsBarplotStyle] at (FloodSomePts1-|SuiteTopo1) (PixelIsFBFS1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Highly unlikely,Unlikely,Possible,Likely,Highly likely}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.449,Highly unlikely)(0.208,Unlikely)(0.107,Possible)(0.113,Likely)(0.123,Highly likely)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{PixelIsFBFS1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth, text=red](PixelIsFBFS2)[above=0pt of PixelIsFBFS1]{Pixel is FBFS};

%%%%
%%%%

\node[BnsBarplotStyle] at (PixelIsFBFS1-|FloodBgs1) (VegVarFlood1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.304,Very low)(0.226,Low)(0.169,Medium)(0.154,High)(0.147,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{VegVarFlood1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](VegVarFlood2)[above=0pt of VegVarFlood1]{Vegetation variation due to flood};

%%%%

%%%%

\node[BnsBarplotStyle, below= of VegVarFlood1] (TempoVarVI1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Extremely low,Very low,Low,High,Very high, Extremely high}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.285,Extremely low)(0.118,Very low)(0.183,Low)(0.156,High)(0.036,Very high)(0.222,Extremely high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{TempoVarVI1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](TempoVarVI2)[above=0pt of TempoVarVI1]{Vegetation variation due to flood};

%%%%
%%%%

\node[BnsBarplotStyle] at (TempoVarVI1-|PixelIsFBFS1) (PowerTools1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Low,High}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.200,Low)(0.800,High)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{PowerTools1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](PowerTools2)[above=0pt of PowerTools1]{Power of Tools};

%%%%
%%%%

\node[BnsBarplotStyle] at (PowerTools1-|FloodSomePts1) (WaterPresent1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Unexpected,Unusual,Common,Permanent}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.200,Unexpected)(0.200,Unusual)(0.200,Common)(0.200,Permanent)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{WaterPresent1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](WaterPresent2)[above=0pt of WaterPresent1]{Water present};

%%%%

%%%%

\node[BnsBarplotStyle, below= of WaterPresent1] (Exposure2wet1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates {(0.200,Very low)(0.200,Low)(0.200,Medium)(0.200,High)(0.200,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{Exposure2wet1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](Exposure2wet2)[above=0pt of Exposure2wet1]{Exposure to wetness};

%%%%

%%%%

\node[BnsBarplotStyle, below= of Exposure2wet1] (Sens2Flood1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.200,Very low)(0.200,Low)(0.200,Medium)(0.200,High)(0.200,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{Sens2Flood1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](Sens2Flood2)[above=0pt of Sens2Flood1]{Sensitivity to flood};

%%%%

%%%%

\node[BnsBarplotStyle] at (Exposure2wet1-|PowerTools1) (SoilWaterContent1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low,Medium,High,Very high}
                  ]

\addplot [AddPlotStyle]  coordinates {(0.200,Very low)(0.200,Low)(0.200,Medium)(0.200,High)(0.200,Very high)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{SoilWaterContent1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](SoilWaterContent2)[above=0pt of SoilWaterContent1]{Soil water content};

%%%%

%%%%

\node[BnsBarplotStyle, below= of SoilWaterContent1] (SuitSoil1)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Unusable,Unsuitable,Moderately suitable,Suitable,Highly suitable}
                  ]

\addplot [AddPlotStyle]  coordinates{(0.293,Unusable)(0.155,Unsuitable)(0.105,Moderately suitable)(0.154,Suitable)(0.293,Highly suitable)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{SuitSoil1}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](SuitSoil2)[above=0pt of SuitSoil1]{Suitable soil};

%%%%
%%%%%
\draw[thickarrow] (VegVar2Water1) -- (CharctVeg2);
\draw[thickarrow] (Slope1) -- (SuiteTopo2);

\draw[thickes] (FlowAcc1.west) -- ([xshift=-1cm]FlowAcc1.west);
\draw[thickes] ([xshift=-1cm]FlowAcc1.west)--([xshift=-1cm]FlowAcc1.west|-SuiteTopo1.east);
\draw[thickarrow] ([xshift=-1cm]FlowAcc1.west|-SuiteTopo1.east)-- (SuiteTopo1.east);

\node[draw=none, fill=none] at ([xshift=1.1cm]FlowAcc1.east){};
\draw[thickes] (FlowAcc1.east) -- ([xshift=1cm]FlowAcc1.east);
\draw[thickes] ([xshift=1cm]FlowAcc1.east) -- ([xshift=1cm]VegVarFlood1.east);
\draw[thickarrow] ([xshift=1cm]VegVarFlood1.east) -- (VegVarFlood1.east);

\draw[thickarrow] (FloodBgs1) -- (VegVarFlood2);
\draw[thickarrow] (VegVarFlood1) -- (PixelIsFBFS1);
\draw[thickarrow] (SuiteTopo1) -- (PixelIsFBFS2);
\draw[thickarrow] (FloodSomePts1) -- (PixelIsFBFS1);
\draw[thickarrow] (CharctVeg1) -- (FloodSomePts2);

\draw[thickes] ([yshift=-0.5cm]Sens2Flood1.west) -- ([xshift=-0.5cm, yshift=-0.5cm]CharctVeg1.west|-Sens2Flood1.west);
\draw[thickes] ([xshift=-0.5cm, yshift=-0.5cm]CharctVeg1.west|-Sens2Flood1.west) -- ([xshift=-0.5cm]CharctVeg1.west);
\draw[thickarrow] ([xshift=-0.5cm]CharctVeg1.west) -- (CharctVeg1.west);
\node[draw=none, fill=none] at ([xshift=-0.65cm]CharctVeg1.west|-Sens2Flood1.west){};


\draw[thickes] (Sens2Flood1.west) -- ([xshift=-0.5cm]Sens2Flood1.west-|WaterPresent1.west);
\draw[thickes] ([xshift=-0.5cm]Sens2Flood1.west-|WaterPresent1.west) -- ([xshift=-0.5cm]WaterPresent1.west);
\draw[thickes] ([xshift=-0.5cm]Sens2Flood1.west-|WaterPresent1.west) -- ([xshift=-0.5cm]WaterPresent1.west);
\draw[thickarrow] ([xshift=-0.5cm]WaterPresent1.west) -- (WaterPresent1.west);

\draw[thickes] (SuitSoil1.south) -- ([yshift=-0.5cm]SuitSoil1.south);
\draw[thickes] ([yshift=-0.5cm]SuitSoil1.south) -- ([yshift=-0.5cm, xshift=-1.2cm]SuitSoil1.south-|FloodSomePts1.west);
\draw[thickes] ([yshift=-0.5cm, xshift=-1.2cm]SuitSoil1.south-|FloodSomePts1.west) -- ([xshift=-1.2cm]FloodSomePts1.west);
\draw[thickarrow] ([xshift=-1.2cm]FloodSomePts1.west) -- (FloodSomePts1.west);
\node[draw=none, fill=none] at ([yshift = -0.65cm]SuitSoil1.south){};

%(FloodSomePts1.west);

\draw[thickarrow] (WaterPresent2) -- (FloodSomePts1);
% \draw[thickarrow] (PowerTools1) -- (WaterPresent1);
% \draw[thickarrow] (PowerTools1) -- (TempoVarVI1);
\draw[thickarrow] (PowerTools2) -- (PixelIsFBFS1);
\draw[thickarrow] (TempoVarVI2) -- (VegVarFlood1);

\draw[thickes] ([xshift=1cm]WaterPresent2.north) -- ([xshift=1cm, yshift=1cm]WaterPresent2.north);
\draw[thickes] ([xshift=1cm, yshift=1cm]WaterPresent2.north)--([xshift=-1cm, yshift=1cm]WaterPresent2.north-|VegVarFlood1);
\draw[thickarrow] ([xshift=-1cm, yshift=1cm]WaterPresent2.north-|VegVarFlood1)--([xshift=-1cm]VegVarFlood1.south);

%\draw[thickarrow] (WaterPresent2) -- (VegVarFlood1);

\draw[thickarrow] (Exposure2wet2) -- (WaterPresent1);

\draw[thickes] ([xshift=-0.25cm]Exposure2wet1.south)--([xshift=-0.25cm, yshift=-0.75cm]Exposure2wet1.south);
\draw[thickes] ([xshift=-0.25cm, yshift=-0.75cm]Exposure2wet1.south) -- ([xshift=-0.5cm, yshift=-0.75cm]SuitSoil2|-Exposure2wet1.south);
\draw[thickarrow] ([xshift=-0.5cm, yshift=-0.75cm]SuitSoil2|-Exposure2wet1.south) -- ([xshift=-0.5cm]SuitSoil2.north);


\draw[thickes] (Exposure2wet1.south)--([yshift=-0.5cm]Exposure2wet1.south);
\draw[thickes] ([yshift=-0.5cm]Exposure2wet1.south)--([yshift=-0.5cm]Exposure2wet1.south-|VegVarFlood1);
\draw[thickarrow] ([yshift=-0.5cm]Exposure2wet1.south-|VegVarFlood1)--(TempoVarVI1.south);

%\draw[thickarrow] (Exposure2wet2) -- (TempoVarVI1);

\draw[thickes] ([xshift=-1cm]SoilWaterContent2.north) -- ([xshift=-1cm, yshift=0.25cm]SoilWaterContent2.north);
\draw[thickes] ([xshift=-1cm, yshift=0.25cm]SoilWaterContent2.north) -- ([xshift=1cm, yshift=0.25cm]SoilWaterContent2.north-|WaterPresent1.south);
\draw[thickarrow] ([xshift=1cm, yshift=0.25cm]SoilWaterContent2.north-|WaterPresent1.south) -- ([xshift=1cm]WaterPresent1.south);

%(WaterPresent1);
\node[draw=none, fill=none] at ([yshift=-1.1cm]SoilWaterContent1.south){};
\draw[thickes] (SoilWaterContent1.south) -- ([yshift=-1cm]SoilWaterContent1.south);

%\draw[thickes] ([yshift=-1cm]SoilWaterContent1.south)--([yshift=-1cm]SuitSoil1|-SoilWaterContent1.south);
%\draw[thickarrow] ([yshift=-1cm]SuitSoil1|-SoilWaterContent1.south)--(SuitSoil1.south);
\draw[thickarrow] (SoilWaterContent1.south)--(SuitSoil2.north);


\draw[thickes] ([xshift=1cm]SoilWaterContent2.north) -- ([xshift=1cm, yshift=0.25cm]SoilWaterContent2.north);
\draw[thickes] ([xshift=1cm, yshift=0.25cm]SoilWaterContent2.north) -- ([xshift=-0.5cm, yshift=0.25cm]SoilWaterContent2.north-|TempoVarVI1.south);
\draw[thickarrow] ([xshift=-0.5cm, yshift=0.25cm]SoilWaterContent2.north-|TempoVarVI1.south) -- ([xshift=-0.5cm]TempoVarVI1.south);


\node[draw=none, fill=none] at ([xshift=-0.5cm]SuitSoil1.west){};
\node[draw=none, fill=none] at ([yshift=0.25cm]VegVar2Water2.north){};

%%%%%
\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);
\end{tikzpicture}
%% End of Mapping BNs %%%%
```


```{r table1, echo=FALSE}
library(knitr)
library(kableExtra)
kable(
rbind(
  NDVI = c (`Bands`='B2, B1',	`Spectral range`='(NIR – VISRed)/(NIR + RED)',	`Full name`='Normalized Difference Vegetation Index (Rouse, 1973)'),
  NDFI = c(	'B1, B6',	'(NIR - SWIR1) / (NIR + SWIR1)',	'Normalized Difference Flood Index (Boschetti, 2014)'),
  NDII6	= c('B2, B6', 	'(NIR2 - SWIR1) / (NIR2 + SWIR1)',	'Normalized Difference Infrared Index - Band 6 (Hunt, 1989)'),
  NDII7 = c('B2, B7',	'(NIR2 - SWIR2) / (NIR2 + SWIR2)',	'Normalized Difference Infrared Index - Band 7 (Hunt, 1989)'),
  `GAO MDWI` = c('B2, B5',	'(NIR2 - NIR5) / (NIR2 + NIR5)',	'Normalized Difference Water Index (NDWI) (GAO, 1996)'),
  `McFeeters MDWI` =	c('B4, B2',	'(VIS4 – NIR2) / (VIS4 + NIR2)',	'Normalized Difference Water Index (NDWI) (McFeeters, 1996)')),
format="latex", booktabs=TRUE,
  caption = 'List of normalized difference spectral indices (NDSI) used for mapping FBFS in Kisumu County, Kenya.') %>% 
  row_spec(0,bold=TRUE) %>% 
  column_spec(1,bold=TRUE) %>% 
  kable_styling(latex_options="scale_down")
```

The topographic suitability of a pixel (`suiteTopo`) depends largely on its slope (`Slope`) and the number of pixels draining into it (`FlowAcc`). While the accumulation of flow (`FlowAcc`) is important to the amount of flood reaching the pixels, it is rather the slope (`Slope`) and the gravity that determine whether the water will be kept or transmitted by that pixel.

The extent to which vegetation variation is caused by flood water (`VegVarFlood`) can be a straightforward indicator for mapping flood-based agriculture but also difficult to measure. Vegetation variation caused by flood (`VegVarFlood`) was therefore assessed via proxy variables. For the temporal variation in vegetation indices (`TempoVarInVi`) to be attributed to flood to some extent (`VegVarFlood`) at a given pixel, one may expect a certain degree of flow accumulation (`FlowAcc`), and a certain likelihood of flood events near the beginning of the growing season (`FloodBgs`). Then, the temporal variation in vegetation (`TempoVarInVi`) of the pixel is assumed to be influenced by a number of factors such as its soil water content (`SoilwaterCont`), its exposure (`Expos2wet`) and sensitivity to flood (`Sens2Flood`), or even the quality of the data in relation with the type of algorithm used in processing these data (`PowerTools`).

For a given pixel to be flooded at some points (`FloodSomePts`), there must be water presence on the ground (`WaterPrznt`). This is moderated by the soils suitability (`SuitSoil`) resulting in specific type of vegetation (`CharactVeg`). Therefore, the extent to which a pixel is flooded (`FloodSomePts`) can be deduced from its typical vegetation (`CharactVeg`), the soil suitability (`SuitSoil`), and the presence of water (`WaterPrznt`). Soil suitability to FBFS is defined by its exposure to wetness (`Expos2wet`) and more importantly its water content (`SoilWaterCont`). Water presence (`WaterPrznt`) may depend on soil water content (`soilWaterCont`), the power of tools (`PowerTools`), and the sensitivity to flood (`Sens2Flood`). Characteristic FBFS’ vegetations are assumed to be due to vegetation sensitivity to water variation (`Veg2waterVar`) and the sensitivity of the area to flood (`Sens2Flood`).

### The shapefiles data {#I32}

The shapefiles of the study areas were acquired from the [global administrative boundaries database](https://gadm.org/) [@GADM_2018] as level 1 product, using the string country name as argument to [`getData`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/getData) function from the `raster` package [@Hijmans_2019], from which we extracted the shapefile of the area of interest. These shapefiles were latter used to identify the [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) H/V titles corresponding to the area. Other shapefiles used are the spatial polygons representing well known selected surface features (land use/ land cover) used to understand the behaviour of the spectral response in the area. These were either collected during field works using handheld GPS devices or digitized on Google Earth to be used to query the spectral response of pixels they match spatially. The surfaces features considered here include different depth water bodies, settlements, FBFS fields, rainfed agricultural fields, riparian forests, forests with varying degree of density, and sugarcane fields having relatively extended growing season.

### MODIS Tera {#I33}

We considered a period of three years (2014 - 2016) and queried all available [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) `Tera` data overlapping the acquired shapefiles of the area of interest (section \@ref(I32)). We first determined the Horizontal and Vertical tiles corresponding to the spatial coverage of the shapefiles and used these to define the appropriate geo-locations of the study area relative to the [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) Sinusoidal grid systems using the [`getTiles`](https://www.rdocumentation.org/packages/MODIS/versions/1.1.4/topics/getTile) function from the `MODIS` package [@Mattiuzzi_and_Detsch_2018]. As result, the Kisumu County falls in-between the `h21v09` and `h21v08`. Based on these tiles and the temporal window of interest, we mosaiced the images and calculated the NDSIs after filtering and downloading the data from MODIS global online database (i.e. LP DAAC, LAADS) using the machine-to-machine routines embedded in the [`MODIStsp`](https://www.rdocumentation.org/packages/MODIStsp/versions/1.3.2) function from the package of the same name [@Busetto_and_ranghetti_2016]. Since the [MODIS](https://terra.nasa.gov/about/terra-instruments/modis) data are provided in hierarchical data format (hdf), they were re-projected to World Geodetic System 1984 (`WGS 84`) and subsequently translated into Geotiff format using [`GDAL 2.2.3`](https://www.gdal.org/) [@GDAL_OGRcontributors_2018].

## Making sense of data in the context {#I4}

Prior to processing the data acquired, preliminary analyses were conducted to understand the behavior of the spectral response with regards to water and vegetation in the study area. These analyses include the boxplot of the time series to understand the temporal variability and the principal component analysis to depict the spatio-temporal pattern. The results are presented in the supplementary materials.

## Derivation of spatial data nodes {#I5}

### General Procedure {#I51}

#### Time series data {#I511}

The boxplots and the comparative analysis of the NDSIs shows different patterns but these can only be hardly separated making it difficult to threshold the different NDSIs across land use / land cover. An approach based on rigid thresholding was clearly not the best option to demarcate the nature of the spectral response, at least not without making complicated statistical assumptions. A simpler way would be to approach the problem using imprecise quantifiers where fuzzy logic can be used in forms of Likert-type scales [@Likert_1932] describing the scores of the spectral responses along a range; supporting the use of [BNs](https://en.wikipedia.org/wiki/Bayesian_network). We therefore make use of the different ranges of the boxplot (i.e. lowest outliers – lower Whisker, lower Whisker - 1st quartile,  1st quartile – 3rd quartile, 3rd quartile -  upper Whisker , upper Whisker – highest outliers) to separate the data and estimate the probability of each pixel falling within each of these ranges at each time step in the time series.

\begin{algorithm}[H]
\SetKw{KwBy}{by}
\DontPrintSemicolon
\SetAlgoLined
\KwResult{a spatially explicit quantitative representation of variable states using probability}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{NDSI time series stack}
\Output{a raster stack where each layer represents one of the variable states}
\BlankLine
\For{$each\;layer\;in\;the\;time\;series$}{
    compute Whisker ranges\;
    \For{$each\;Whisker\;range$}{
        \eIf{cell value belongs to the Whisker range}{
        recode the cell value to 1\;
    }{
        recode the cell value to 0\;
    }
    compute the probability of getting 1
}
}
\caption{make pixel states}
\end{algorithm}

Although rarely use for deriving variable states, boxplot has been used in all kind of statistics for the last 40 years. Beyond their incredible simplicity, boxplots use robust statistics to summarise data in terms of five-numbers while being particularly handy when comparing the distributions of these data across groups [@Wickham_and_Stryjewski_2012]. To estimate the probability for a given range, we first recoded all values outside of that range to 0 whereas the values falling within the range were recorded to 1. This way, all the real-valued time series was reclassified into presence - absence time series data. Thereafter, the final probability of a pixel belonging to a range can be easily estimated using the ratio between the presence and absence of that pixel in the range throughout the time series (Equation \@ref(eq:eq1)).

\begin{equation} 
P(p_i \in range_j) = \frac{n_{p_i \in range_j}}{N}
(\#eq:eq1)
\end{equation}

Where $P(p_i \in range_j)$ is the probability of the pixel $p_i$ belonging to the range $range_j$, $n_{p_i \in range_j}$ is the number of time the pixel $p_i$ belonged to the range $range_j$, and $N$ is the sample space (total size of the time series). 

After estimating the probabilities for each boxplot range, these ranges were mapped into fuzzy linguistic quantifiers in forms of low, medium, high etc. (depending on the number of states identify by the boxplot algorithm) to provide vegetation states in a spatially explicit manner. For example, in situation where all the five boxplot ranges are present, lower outlier values were mapped to very low, the lower Whisker to low, the interquartile range to medium, the upper Whisker to high and the upper outliers to very high. These states, computed in separated raster layers, were then merged into one single layer to provide discrete states on which the [BNs](https://en.wikipedia.org/wiki/Bayesian_network) can be easily operationalized.

\begin{algorithm}[H]
\SetKw{KwBy}{by}
\DontPrintSemicolon
\SetAlgoLined
\KwResult{a spatially explicit qualitative representation of variable states using common language}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{NDSI time series stack}
\Output{a raster layer where pixels are represented using relative fuzzy linguistic quantifiers}
\BlankLine
\textbf{do} algorithm 1: make pixel states\ \label{lst:line:s1}\;
\For{$each\;pixel$}{
        \eIf{the pixel has one single maximum for all layers}{
        assign to the pixel the position of the layer (corresponding to a Whisker range as in the stack generated at step~\ref{lst:line:s1} and mapping to a linguistic quantifier) holding that maximal (probability) value \;
    }{
        assign NA to the pixel\ \label{lst:line:s2};
    }
    \For{$each\;pixel\;holding\;NA\;in\;the\;layer\;(generated\;after\;step~\ref{lst:line:s2})$}{
        \eIf{the pixel has one single maximum for all neighbours in the 8 ways connectedness}{
        fill it with that maximal value \;
        }{
        leave the pixel value as NA\ \label{lst:line:s13};
        }
            get the position of the remaining pixel holding after step~\ref{lst:line:s13} \;
            extract all pixel values at the positions in step~\ref{lst:line:s13} from the stack generated at step~\ref{lst:line:s1} \label{lst:line:s14}\;
            fit a classification regression tree model to the extracted data in step~\ref{lst:line:s14} \label{lst:line:s15}\;
            predict the remaining pixels holding NA after step~\ref{lst:line:s13} using the model developed at step~\ref{lst:line:s15}
    }
}
\caption{compile pixel states}
\end{algorithm}

The decision to assign a state value to a given pixel was made transparently using fully probabilistic heuristics in 3 sequential steps. The first step consisted in assigning a particular state to a given pixels if that state scored the highest probability and only if that highest probability is exclusive. Thus, all cases where 2 or more highest probability co-exist are considered as unknown and ignore until the second step. Such cases having equal probability states were commonly encountered at the edges where two consecutive states spatially meet. In the second step, these confusing pixels having 2 or more maximal probability of state occurrence are filled in using majority rule. Herein, since spatial feature are geographically auto-correlated in general, we applied a 3 by 3 moving window (eight-way connectedness) centred on each of these uncertain state value pixels and estimate their state value based on the values of the 8 neighbourhood pixels. Similarly, to the first step, a particular value among the values of the 8 neighbours is chosen when and only when it is the only value that occurs the most. Whenever 2 or more states happen to be the most probable at the same time, the pixel is left out and handled at the third step.  In the third step, the rest of these confusing pixels, where the first and second steps heuristics failed, were modelled using decision tree recursive partitioning classification algorithm. We first extracted the maximal values which correspond to the highest probability across all these remaining confusing pixels to fit a classification regression tree (CART) model and used that model to conditionally infer their state values. Therefore, after this third step all pixel state value were estimated, and the resulting raster can be used as spatial data node in the [BNs](https://en.wikipedia.org/wiki/Bayesian_network) model. The boxplot statistics were computed using our own defined function (see `get_boxplot_1d` in the technical material) based on [`boxplot.stats`](https://www.rdocumentation.org/packages/grDevices/versions/3.5.3/topics/boxplot.stats) function from the `grDevices` package [@RCoreTeam_2018]. We used the [`reclassify`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/reclassify) and the [`calc`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/calc) functions both from the `raster` package [@Hijmans_2019] to recode the pixel values and to estimate the probability respectively. The second step confusing pixels were handled using [`modal`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/modal) function from within the [`focal`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/focal) function also from the `raster` package [@Hijmans_2019]. The CART model was fitted using the [`ctree`](https://www.rdocumentation.org/packages/party/versions/1.3-3/topics/Conditional%20Inference%20Trees) function from the `party` package [@Hothorn_et_al_2006] whereas the third step confusing pixels’ inference was achieved by supplying an anonymous function wrapping the [`predict`](https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/predict) function from the `stats` package [@RCoreTeam_2018] as argument to [`calc`](https://www.rdocumentation.org/packages/raster/versions/2.8-19/topics/calc) function [@Hijmans_2019].

#### Single layer data {#I512}

In the case of single layer data where time series does not make sense (e.g. slope and flow accumulation) or where nodes were derived from times series as single layer (e.g. exposure to wetness, vegetation sensitivity to water), a slightly different procedure compared to that adopted for time series data was adopted for [BNs](https://en.wikipedia.org/wiki/Bayesian_network) nodes making. We rather used the boxplot’s five-numbers approach in a much straightforward way by exploiting the spatial variability across cell values since the temporal component of this variability no longer exists. We first extracted all pixel values and computed the five-numbers from which ranges corresponding to discrete states were computed. These ranges were then directly recoded into unique values mapping to fuzzy linguistic quantifiers. The process is somewhat a simple raster reclassification task except that the reclassification matrix was derived directly from the natural breaks of the data.

### Specific procedure {#I52}

Specific processing procedures were applied to derive each spatial data node considered in the [BNs](https://en.wikipedia.org/wiki/Bayesian_network). These are described in detail in the supplementary material. We explained the meaning of each node, provided the rational of its usage and described how it is causally related to other nodes in the [BNs](https://en.wikipedia.org/wiki/Bayesian_network). Some nodes (e.g. Soil water content) were indirectly estimated as composite variable involving several NDSIs. Other (Exposure to wetness) were simply computed using single metric time series. In some other cases, the computation involved complex algorithm applied either to time series data (Temporal variation in vegetation) or to single layer (Flow accumulation) depending on the nature of the data.

# Results and discussion {#II}

```{r making sense of the data,echo=FALSE,include=FALSE}
## Making sense of the data: examing the NDVI values #####
f <- function(x, decimals = 1){
  x <- x/10000
  # as.character(round(x,decimals))
  sprintf("%.1f", x)
} 

p <- ggplot_seasonal_ranges(list(
  NDVI=ndvi_ts,
  'MDWI (mcfeeters, 1996)' = mcfeeters_NDMI_ts, 
  NDFI=Boschetti_NDFI_ts,
  'MDWI (Gao, 1996)' = GAO_NDWI_ts))+
  my_theme +
  # guides(color = FALSE)+
  theme(panel.grid.minor.y = element_line(size = 0.02, linetype = 'solid',color = 'darkgray'),
        axis.title = element_blank())+
  scale_x_date(date_breaks = "4 months", date_minor_breaks = "1 month", date_labels =  "%b \n%Y", expand = c(0,0),
               labels=function(x) sub(" ","d",x,fixed=TRUE))+
  scale_y_continuous(labels = f, breaks = scales::pretty_breaks(n=4), expand = c(0, 0))+
  labs(title='Kisumu County, Kenya', 
       subtitle=paste0('MODIS', ' : ', '2014-01-01', ' ', '/', ' ', '2016-12-26'))
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
p <- grid.arrange(p, ncol=1)
p <- gTree(children = gList(p, gb))

```

```{r fig3,echo=FALSE,fig.width=7.54,fig.height= 5.79,dpi=300,dev.args=list(png = list(type = "cairo")),fig.cap="Temporal variability in water and vegetation in Kisumu county, Kenya."}
grid.draw(p)
```

```{r fig3 export,echo=FALSE,include=FALSE}
ggsave(plot=p, device = 'png', filename = "figures/seasonal_ranges_plot.png", width = 7.54, height = 5.79, dpi = 300)
```


```{r fig water and vegetaion states export,echo=FALSE,include=FALSE}
## Spatially explicit representation of some of the patterns in the Boxplot ####
# The ggplot has shown various pattern. it would be nice to see them in space.
# In the following we will extract some of these patterns and present them spatially. 

## Probaility of vegetation ####

# Dicretizing the ndvi raster stack to make vegetation probability
# This is gona be sweet !!! 
ficher <- 'output_files/Kisumu_veg_coverage.grd'
if(!file.exists(ficher)){
  p <- make_pixel_states(ndvi_ts, split_IQR = TRUE, op = 'proba', filename = ficher)
} else {
  p <- brick(ficher)
}

veg_coverage <- p
# plot(p)
labeller = c('Very low (lower outliers)', 'Low (lower Whisker)', 'Moderately low (lower IQR)', 
             'Moderately high (upper IQR)','High (upper Whisker)', 'Very high (upper outliers)')


names(labeller) <- names(p)
labeller = as_labeller(labeller)

# # ggploting the rasters
# my_subtitle <- expression(paste('MODIS NDVI','   '^ 
#                                   italic("  cell values are probabilities of the corresponding\nstate based the time series")), col = "red")
my_subtitle <- expression(paste('MODIS NDVI'))

f <- function(decimals=0){
  # return a function responpsible for formatting the 
  # axis labels with a given number of decimals 
  function(x) as.character(round(x,decimals))
}


p1 <- rasterVis::gplot(p)+
  geom_raster(aes(fill = value)) +
  facet_wrap(~ variable, labeller = labeller, ncol = 3) +
  scale_fill_gradientn(colours=rev(terrain.colors(255)))+
  theme_minimal()+
  my_theme +
  theme(legend.text = element_text(family = 'serif', face = 'plain', size = 10),
        legend.box.margin=margin(-22, 1, -10, 0),
        strip.text = element_text(size = 12),
        axis.text.y = element_text(size = 11),
        axis.text.x = element_blank(),
        axis.title = element_blank(),
        plot.title = element_blank(),
        # plot.margin = margin(b=-0.5, unit = 'cm'),
        plot.margin = margin(b=-0.25, unit = 'cm'),
        plot.subtitle = element_text(size = 16, margin=margin(0,0,-2.5,0)))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0.015)) +
  scale_y_continuous(expand = c(0, 0.015))+
  labs(subtitle=my_subtitle)+
  guides(fill=guide_colourbar(barwidth=20, barheight = 0.5, label.position="bottom"))

p1 <- gTree(children = gList(ggplotGrob(p1), gb))

# grid.newpage()
# p1 <- grid.arrange(p, ncol=1)
# p <- gTree(children = gList(p, gb))
# ggsave(plot=p, device = 'png', filename = "figures/veg_states_plot.png", dpi = 300,
#        height = 8.75-1.558, units = 'in')

## Probaility of water ####

# Dicretizing the NDFI raster stack to make water probability
ficher <- 'output_files/Kisumu_flood_coverage.grd'
if(!file.exists(ficher)){
 p <- make_pixel_states(Boschetti_NDFI_ts, split_IQR = TRUE, op = 'proba', filename = ficher)
} else {
 p <- brick(ficher)
}
flood_coverage <- p
# # ggploting the rasters
my_subtitle <- expression(paste('MODIS NDFI'))
col0 = RColorBrewer::brewer.pal(n = 6, name = "Blues")
col1 = rev(terrain.colors(5))
col1= c(col0[c(1)],
       col1[c(-1,-4, -5)],
       col0[c(3,4,5)])
col1=colorRampPalette(col1)(255)

midpoint <- median(p[], na.rm = TRUE)
p <- rasterVis::gplot(p)+
  geom_raster(aes(fill = value)) +
  facet_wrap(~ variable, labeller = labeller, ncol = 3) +
  scale_fill_gradientn(colours = col1)+
  theme_minimal()+
  my_theme +
  theme(legend.text = element_text(family = 'serif', face = 'plain', size = 10),
        legend.box.margin=margin(-22, 1, -10, 0),
        strip.text = element_text(size = 12),
        axis.text.y = element_text(size = 11),
        # axis.text.x = element_blank(),
        axis.title = element_blank(),
        plot.title = element_blank(),
        # plot.margin = margin(b=-0.5, unit = 'cm'),
        plot.margin = margin(b=-0.25, unit = 'cm'),
        plot.subtitle = element_text(size = 16, margin=margin(0,0,-2.5,0)))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0.015)) +
  scale_y_continuous(expand = c(0, 0.015))+
  labs(subtitle=my_subtitle)+
  guides(fill=guide_colourbar(barwidth=20, barheight = 0.5, label.position="bottom"))

p <- gTree(children = gList(ggplotGrob(p), gb))

grid.newpage()
p <- list(p1, p)
p$ncol = 1
p$top = grid::textGrob("Kisumu County, Kenya: MODIS 2014-01-01 / 2016-12-26.",
                       x=0, hjust=0, vjust = 0.5,
                       gp = gpar(fontfamily='serif',fontsize=16,fontface="bold", col="black"))
p$bottom = grid::textGrob("Long",
                          x=0.5, hjust=0, vjust = 0.5,rot = 0,
                          gp = gpar(fontfamily='serif',fontsize=16,fontface="bold", col="black"))
p$left = grid::textGrob("Lat",
                        rot = 90,
                        gp = gpar(fontfamily='serif',fontsize=16,fontface="bold", col="black"))

p$heights = c(7.192/2.05, 7.192/1.95)

p <- do.call(grid.arrange, p)
p <- gTree(children = gList(p, gb))
```

```{r fig4,echo=FALSE,fig.width=7.54,fig.height= 7.192,dpi=300,fig.cap="Discrete states of vegetation and water in Kisumu county, Kenya."}
grid.draw(p)
```

```{r fig4 export,echo=FALSE,include=FALSE}
ggsave(plot=p, device = 'png', filename = "figures/veg_water_states_plot.png", dpi = 300, width = 7.54,
       height = 7.192, units = 'in')
```

```{r table2, echo=FALSE}
ficher <- 'output_files/Kisumu_compiled_flood_coverage.grd'
if(!file.exists(ficher)){
  flood_coverage <- compile_pixel_states(flood_coverage, split_IQR = TRUE, as_states=TRUE)$output
  writeRaster(flood_coverage, filename = ficher)
} else {
  flood_coverage <- raster(ficher)
}
# water_prznt <- flood_coverage # save that node for latter


ficher <- 'output_files/Kisumu_compiled_veg_coverage.grd'
if(!file.exists(ficher)){
  veg_coverage <- compile_pixel_states(veg_coverage, split_IQR = TRUE, as_states=TRUE)$output
  writeRaster(veg_coverage, filename = ficher)
} else {
  veg_coverage <- raster(ficher)
}


get_coverages <- function(x, poly){
  x <- mask(x, poly)
  target = unique(x[])
  target = sort(target[!is.na(target)])
  names(target) <- target
  surf <- area(x)
  
  sapply(target, function(i){
    msk <- x
    msk[msk != i] <- NA
    out <- mask(surf, msk)
    sum(out[], na.rm = TRUE)
  })
}

flood_coverage <- get_coverages(flood_coverage, Kisumu)
veg_coverage <- get_coverages(veg_coverage, Kisumu)

coverage <- matrix(NA, nrow = 2, ncol = 6)

for (i in as.numeric(names(veg_coverage))) {
  coverage[1, i] <- veg_coverage[as.character(i)]
}

for (i in as.numeric(names(flood_coverage))) {
  coverage[2, i] <- flood_coverage[as.character(i)]
}

cov_perc <- (coverage*100)/(area(Kisumu)/1000000)

coverage <- mapply(function(x,y) {
  if(is.na(x)){
    out <- " "
  } else {
    out <- paste(round(x, 2), "\n", "(", round(y, 2), "%", ")", sep = "")
  }
  out
  }, 
  coverage, cov_perc)

coverage <- matrix(coverage, nrow=2)
colnames(coverage) <- c("Very low", "Low", "Moderately Low", "Moderately High", "High", "Very high")
rownames(coverage) <- c("Vegetation", "Flood")

kable(
coverage,
format="latex", booktabs=TRUE,
  caption = 'Spatial coverage of different states of vegetation and flood in Kisumu County, Kenya.') %>%
  row_spec(0,bold=TRUE) %>%
  column_spec(1,bold=TRUE) %>%
  kable_styling(latex_options="scale_down")
```
## Prior spatial distribution of the spatial data node states {#II4}

The results of the processed spatial data nodes used to feed the [BNs](https://en.wikipedia.org/wiki/Bayesian_network) model are presented in Figure \@ref(fig:fig11). As it can be seen, the topographic characteristics of the area are captured in both slope and flow accumulation nodes. In Kisumu county, run-off flows from East to West with most of the flow converging to Lake Victoria which is the flattest land located in vast low laying lands. In the East of the Lake basin are the steepest lands of Kisumu causing the essential of surface water to flow Westwards. Most poor-quality data are located around the water bodies where the node power of tools scored the lowest values to an extent that most water bodies are clearly visible. The chance of encountering water on the ground (water present node), either in forms of floods water or water body, is high in most area of Kisumu. This seems to be frequent towards the beginning of the growing season since there is no big difference between the map of the node water present and that of the node flood at the beginning of the rainy season.  In general, vegetation in Kisumu experiences high intra-annual variation with, unexpectedly, the highest variability associated with Lake Victoria. While vegetation is high in the littoral zone, there seems to be a permanent mixture of vegetation and water in the deep water suggesting possible Eutrophication of Lake Victoria. As expected, the spatial pattern of soil water content mimic that of the exposure to wetness (also water present and flood at the beginning of the rainy season) with the Lake Victoria scoring the highest values.  In general, there a drastic moisture within the flat area beyond the lake water; which moisture increases towards the eastern and the northern parts of the county. The highest sensitivity to flood is encountered in the Lake shore. Some forested areas are wrongly detected as high flood sensitivity spots in the north and west eastern of the county towards the neighboring Nandi and Kericho counties. Vegetation sensitivity to water variation, which seems to be negatively correlated with forest and open water, decrease from the literal Lake Victoria outwards.

<!-- ```{r fig11, echo=FALSE, out.width = '100%', fig.cap="Prior spatial data used to feed the BNs for mapping FBFS in Kisumu county, Kenya."} -->
<!-- knitr::include_graphics("figures/Mapping_FBFS_prior_maps.png") -->
<!-- ``` -->

```{r spatial data nodes,echo=FALSE,include=FALSE}
##  Soil water content node: soil_water_content ####
# this is somehow removing the water in vegetation and water on the ground (flood) from a mixture of water in both 
# vegetation and soil. so, we get an idea of the water in soil
# soil_water_content <- (calc(ndii7_ts, function(i) sum(i, na.rm = T))+
#                          calc(ndii6_ts, function(i) sum(i, na.rm = T))+
#                          2*calc(Boschetti_NDFI_ts, function(i) sum(i, na.rm = T))-
#                          2*calc(ndvi_ts, function(i) sum(i, na.rm = T)))/2
# 

ficher <- 'output_files/Kisumu_soil_water_content.grd'
if(!file.exists(ficher)){
  p <- calc(ndii7_ts, function(i) sum(i, na.rm = T))
  p1 <- calc(ndii6_ts, function(i) sum(i, na.rm = T))
  p2 <- calc(Boschetti_NDFI_ts, function(i) 2*(sum(i, na.rm = T)))
  p3 <- calc(ndvi_ts, function(i) -2*(sum(i, na.rm = T)))
  p <- brick(p, p1, p2, p3)
  soil_water_content <- calc(p, function(i) sum(i, na.rm = T)/2, filename = ficher)
  rm(p, p1,p2,p3)
} else {
  soil_water_content <- raster(ficher)
}

soil_water_content <- discretize_raster(soil_water_content, split_IQR = TRUE)

##  Exposure to wetness node:exposure2wetness ####
## this is the total flood recorded over the time series.
ficher <- 'output_files/Kisumu_exposure2wetness.grd'
if(!file.exists(ficher)){
  exposure2wetness <- calc(Boschetti_NDFI_ts, function(x) sum(x, na.rm = T), filename = ficher)
# plot(exposure2wetness)
} else {
  exposure2wetness <- raster(ficher)
}

exposure2wetness <- discretize_raster(exposure2wetness, split_IQR = TRUE)

## Sensitivity to flood node: sensitivity2flood ####
# This is just the absolute standard error, somewhat how fast the flood index is changing throughout the time. 

ficher <- 'output_files/Kisumu_sensitivity2flood.grd'
if(!file.exists(ficher)){
  sensitivity2flood <- calc(Boschetti_NDFI_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)),
                            filename=ficher)
} else {
  sensitivity2flood <- raster(ficher)
}
sensitivity2flood <- discretize_raster(sensitivity2flood, split_IQR = TRUE)

##  Vegetation sensitivity to water node: veg_sensitivity2water ####
# similar to  Sensitivity to flood node 
# vegetation/soil water using the ndii6
# >>> ndii6_var <- calc(ndii6_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation/soil water using the ndii7
# >>> ndii7_var <- calc(ndii7_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation density using ndvi
# >>> veg_variability <- calc(ndvi_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation sensitivity to water adding the water content (in soil/vegetation) from SWIR2 and SWIR3 
# and dividing 2*ndvi. therefore this is just the ratio water-vegetation. 2*ndvi because of the use of the 
# 2 SWIR chanels.

ficher <- 'output_files/Kisumu_veg_sensitivity2water_var.grd'
if(!file.exists(ficher)){
veg_sensitivity2water_var <- (calc(ndii6_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)))+
                                calc(ndii7_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T))))/
  (2*calc(ndvi_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T))))

veg_sensitivity2water_var <- writeRaster(veg_sensitivity2water_var, filename = ficher)
} else {
  veg_sensitivity2water_var <- raster(ficher)
}

veg_sensitivity2water_var <- discretize_raster(veg_sensitivity2water_var, split_IQR = TRUE)

ficher <- 'data_files/dem/Kisumu/Kisumu_dem_mosaic_cropped_flow_acc.tif'

if(!file.exists(ficher)){
RTauDEM::getDEM(shp=Kisumu, path = "data_files/dem/Kisumu")

.wd <- getwd()
setwd('data_files/dem/Kisumu')
dem <- list.files(pattern = '.tif')
dem <- dem[grepl(pattern = 'srtm', dem)]
dem <- paste(dem, collapse = ' ')
cmd <- paste("gdalbuildvrt Kisumu_dem_mosaic.vrt", dem)
system (cmd)
dem <- 'Kisumu_dem_mosaic_cropped.tif'
cmd <- paste(c('-te', as.numeric(as.matrix(extent(ndvi_ts)))), collapse = ' ')
cmd <- paste('gdalwarp -of GTiff  -overwrite', cmd, 'Kisumu_dem_mosaic.vrt', dem)
system(cmd)

resample(raster('Kisumu_dem_mosaic_cropped.tif'), ndvi_ts, filename = 'Kisumu_dem_mosaic_cropped_resampled.tif', overwrite=TRUE)

# Pitremove(fun = 'pitremove', demfile = dem)
system('mpiexec -n 8 pitremove -z Kisumu_dem_mosaic_cropped_resampled.tif -fel Kisumu_dem_mosaic_cropped_pitremoved.tif')

system ('mpiexec -n 8 d8flowdir -p Kisumu_dem_mosaic_cropped_flow_dir.tif -sd8 Kisumu_dem_mosaic_cropped_slope.tif -fel Kisumu_dem_mosaic_cropped_pitremoved.tif')
system ('mpiexec -n 8 aread8 -p Kisumu_dem_mosaic_cropped_flow_dir.tif -ad8 Kisumu_dem_mosaic_cropped_flow_acc.tif -nc')
# system ('mpiexec -n 8 areadinf -ang Kisumu_dem_mosaic_cropped_flow_dir.tif -sca Kisumu_dem_mosaic_cropped_flow_acc.tif -nc')

ficher <- 'Kisumu_dem_mosaic_cropped_flow_acc.tif'
f_acc <- raster(ficher)
setwd(.wd)
} else {
  f_acc <- raster(ficher)
}
# downgrading the resolution the modis resolution
# f_acc <- resample(f_acc, ndvi_ts)
f_acc <- discretize_raster(f_acc, split_IQR = FALSE)
f_acc <- focal (f_acc, w=matrix(1,9,9), fun=modal, 
                na.rm=TRUE, NAonly=TRUE, pad=TRUE)

slope <- raster('data_files/dem/Kisumu/Kisumu_dem_mosaic_cropped_slope.tif')
slope <- calc(x = slope, fun = function(x) atan(x)*180/pi)
slope <- resample(slope, ndvi_ts)
slope <- discretize_raster(slope, split_IQR = TRUE)
slope <- focal (slope, w=matrix(1,9,9), fun=modal, 
                   na.rm=TRUE, NAonly=TRUE, pad=TRUE)

## Temporal variation vegetation indices ####

## we calculated the lenght of the growing season from the onset and cessation dates
## interpolate relative to a mean surface and use the anomalies

ficher <- 'output_files/Kisumu_tempo_var_vi.grd'

if(!file.exists(ficher)){
ndvi_var <- par_stack_season_dates(ndvi_ts, valid_range = c(-10000, 10000), filename = 'output_files/Kisumu_lgs.grd', overwrite=TRUE)

## getting the first rainy season which correspond to layer 1 and 2 
first_season <- ndvi_var [[2]] - ndvi_var[[1]]
second_season <- ndvi_var [[4]] - ndvi_var[[3]]


# wndow <- matrix(1,3,3)
# fun: a function to be used by focal
f <- function(x){
  out <- modal(x, na.rm = TRUE, ties = 'NA') # getting the modal values
  out <- ifelse(length(out) == 1, out, NA) # if only one recode it to the most likely in the window else assign NA to it
  out
}

first_season <- focal (first_season, w=matrix(1,3,3), fun=f, na.rm=FALSE, NAonly=TRUE, pad=TRUE)
second_season <- focal (second_season, w=matrix(1,3,3), fun=f, na.rm=FALSE, NAonly=TRUE, pad=TRUE)

## interpolating using Thin plate spline regression
# making an interpolation surface of 5 cells arround, something like 5*500=2500 m 
interp_surf_first_season <- aggregate(first_season, 4)
## getting the xy coords for builing the interpolation model
xy <- data.frame(xyFromCell(interp_surf_first_season, 1:ncell(interp_surf_first_season)))
## getting the pixel values for builing the interpolation model
v <- getValues(interp_surf_first_season)
## Thin plate spline model with fields package
tps <- Tps(xy, v, lon.lat=T)
p <- raster(first_season)
# use model to predict values at all locations
first_season_interp <- interpolate(p, tps)
# plot(first_season_interp)
# removing the local means from each pixel to get the anomalies.
first_season_SE <- first_season - first_season_interp
# plot(first_season_SE)

## interpolating using Thin plate spline regression
# making an interpolation surface of 5 cells arround, something like 5*500=2500 m 
interp_surf_second_season <- aggregate(second_season, 4)
## getting the xy coords for builing the interpolation model
xy <- data.frame(xyFromCell(interp_surf_second_season, 1:ncell(interp_surf_second_season)))
## getting the pixel values for builing the interpolation model
v <- getValues(interp_surf_second_season)
## Thin plate spline model with fields package
tps <- Tps(xy, v, lon.lat=T)
p <- raster(second_season)
# use model to predict values at all locations
second_season_interp <- interpolate(p, tps)
# plot(first_season_interp)
# removing the local means from each pixel to get the anomalies.
second_season_SE <- second_season - second_season_interp
# plot(second_season_SE)

ndvi_var <- first_season_SE + second_season_SE
# fill NA with the most likely value across a 9 by 9 moving window.
ndvi_var <- focal (ndvi_var, w=matrix(1,9,9), fun=function(x, ...) mean(x, na.rm = TRUE), 
                   na.rm=TRUE, NAonly=TRUE, pad=TRUE)
# plot(ndvi_var)
tempo_var_vi <- discretize_raster(ndvi_var, split_IQR = TRUE)
writeRaster(tempo_var_vi, filename = ficher)
# plot(tempo_var_vi)
} else {
  tempo_var_vi <- raster(ficher)
}

## flood_bgs: flood at the beginning of the rainy season #####
ficher <- 'output_files/Kisumu_flood_bgs.grd'
if(!file.exists(ficher)){
# a function for extracting layers in the time series in the near beginning of the rainy season
extract_Zlayer <- function(r_stack,
                           # date_ranges = list (c("2014-02-01", "2014-04-30"), c("2015-02-01", "2015-04-30"), c("2016-02-01", "2016-04-30"),
                           #                     c("2014-07-01", "2014-09-30"), c("2015-07-01", "2015-09-30"), c("2016-07-01", "2016-09-30")),
                           date_ranges = list (c("2014-03-01", "2014-04-30"), c("2015-03-01", "2015-04-30"), c("2016-03-01", "2016-04-30"),
                                               c("2014-08-01", "2014-09-30"), c("2015-08-01", "2015-09-30"), c("2016-08-01", "2016-09-30")),
                           valid_range = c(-1, 1)){
  # dates <- getZ(r_stack)
  dates <-  as.Date(substring(names(r_stack), 2), format = "%Y.%m.%d")
  sel_dates <- unlist(lapply(date_ranges, function(x){
    which(dates >= as.Date(x[1]) & dates <= as.Date(x[2]))
  }))
  out<- r_stack[[sel_dates]]
  # out <- setZ(out, NULL)
  # out<- rts::rts (out,dates[sel_dates])
  return(out)
}

flood_bgs <- extract_Zlayer(Boschetti_NDFI_ts)
flood_bgs <- compile_pixel_states(flood_bgs, split_IQR = FALSE)
flood_bgs <- flood_bgs$output
writeRaster(flood_bgs, filename = ficher)
} else {
  flood_bgs <- raster(ficher)
}

# # water_prznt <- compile_pixel_states(Boschetti_NDFI_ts, split_IQR = FALSE)
# # water_prznt <- water_prznt$output
# water_prznt <- flood_coverage
ficher <- 'output_files/Kisumu_water_prznt.grd'

if(!file.exists(ficher)){
water_prznt <- compile_pixel_states(Boschetti_NDFI_ts, split_IQR = FALSE)
water_prznt <- water_prznt$output
writeRaster(water_prznt, filename = ficher)
} else {
  water_prznt <- raster(ficher)
}
```

```{r Bnspatial,echo=FALSE,include=FALSE}
## combining the spatial data nodes into a list ####

spatialData <- c(f_acc,
                 slope, 
                 p_tools, 
                 water_prznt, 
                 flood_bgs, 
                 tempo_var_vi,
                 soil_water_content,
                 exposure2wetness,
                 sensitivity2flood,
                 veg_sensitivity2water_var
)


## Loading the Bayesian network ####
source("source_files/BNs.R")

## specifying the classes and their boundaries for each spatial data nodes ####
names_spatialData <- c('f_acc',
                       'slope', 
                       'p_tools', 
                       'water_prznt', 
                       'flood_bgs', 
                       'tempo_var_vi',
                       'soil_water_content',
                       'exposure2wetness',
                       'sensitivity2flood',
                       'veg_sensitivity2water_var')

intervals <- setClasses(c("f_acc",
                          "slope",
                          "p_tools",
                          "water_prznt", 
                          "flood_bgs",  
                          "tempo_var_vi",
                          "soil_water_content",
                          "exposure2wetness",
                          "sensitivity2flood",
                          "veg_sensitivity2water_var"), 
                        list(f_acc_node$levels,
                             slope_node$levels, 
                             p_tools_node$levels, 
                             water_prznt_node$levels, 
                             flood_bgs_node$levels, 
                             tempo_var_vi_node$levels,
                             soil_water_content_node$levels,
                             exposure2wetness_node$levels,
                             sensitivity2flood_node$levels,
                             veg_sensitivity2water_var_node$levels),
                        list(sort(unique(f_acc[])),
                             sort(unique(slope[])),
                             sort(unique(p_tools[])),
                             sort(unique(water_prznt[])),
                             sort(unique(flood_bgs[])),
                             
                             sort(unique(tempo_var_vi[])),
                             sort(unique(soil_water_content[])),
                             sort(unique(exposure2wetness[])),
                             sort(unique(sensitivity2flood[])),
                             sort(unique(veg_sensitivity2water_var[])))
)

## linking the network with the spatial data ####
spatialDataList <- linkMultiple(spatialData, network, intervals)


# ## removing objects that are no longer needed ####

## Query the bn and making some maps ####
## please adjust the number of cores par parallel processus
you_have_only_one_core_left <- parallel::detectCores()-30

query_set_names <- nodes(network_bn_fit)[(!(nodes(network_bn_fit) %in% root.nodes(network_bn_fit)))]

query_set <- sapply(query_set_names, function (i){
  # obj <- paste0(i, '_', 'query')
  assign(paste0(i, '_', 'query'), bnspatial(network = network, target = i, spatialData = spatialData, lookup = intervals, inparallel=you_have_only_one_core_left),
         envir=.GlobalEnv)
  
}, simplify = FALSE, USE.NAMES = TRUE)

# query_set_stack <- unlist(query_set)
query_set_stack_class <- sapply(query_set, '[[', 1)
names_query_set_stack_class <- names(query_set_stack_class)
names(query_set_stack_class) <- NULL
query_set_stack_class <- do.call('brick', query_set_stack_class)
names (query_set_stack_class) <- names_query_set_stack_class

query_set_stack_entropy <- sapply(query_set, '[[', 2)
names_query_set_stack_entropy <- names(query_set_stack_entropy)
names(query_set_stack_entropy) <- NULL
query_set_stack_entropy <- do.call('brick', query_set_stack_entropy)
names (query_set_stack_entropy) <- names_query_set_stack_entropy

spatialData <- sapply(spatialDataList, '[[', 4)
names_spatialData <- names(spatialData)
names(spatialData) <- NULL
spatialData <- do.call('brick', spatialData)
names(spatialData)<- names_spatialData
```

```{r Bnspatial plot Kisumu,echo=FALSE,include=FALSE}

# making more intuitive  labels for ggplot facets
labeller0 <- c("Flow accumulation", "Slope", "Power of tools", "Water present", "Flood at the beginning\nof the rainy season", 
               "Temporal variation\nin vegetation index", "Soil water content", "Exposure to wetness", "Sensitivity to flood",
               "Vegetation sensitivity\n to water variation")
names(labeller0) <- names_spatialData
labeller0 = as_labeller(labeller0)

labeller1 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
              "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
              "Vegetation variation \ncaused by flood", 
              "Pixel is FBFS")
names(labeller1) <- names_query_set_stack_class
labeller1 = as_labeller(labeller1)

labeller2 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
              "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
              "Vegetation variation \ncaused by flood", 
              "Pixel is FBFS")
names(labeller2) <- names_query_set_stack_entropy
labeller2 = as_labeller(labeller2)


# # ggploting the rasters

f <- function(decimals=0){
  # return a function responpsible for formatting the 
  # axis labels with a given number of decimals 
  function(x) as.character(round(x,decimals))
}


# col= c("#1B9E77", "#66A61E", "#7570B3", "#D95F02", "#E6AB02", "#E7298A")
p0 <- rasterVis::gplot(spatialData, maxpixels=ncell(spatialData))+
  geom_raster(aes(fill = value)) +
  facet_wrap(~ variable, ncol = 5, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+ 
  my_theme +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 10, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 8),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  labs(subtitle='Prior spatial data nodes')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.35, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))  

p0 <- gTree(children = gList(grid.arrange(p0), gb))


# gplot_data <- function(x, maxpixels=ncell(x), ...){
#   nl <- nlayers(x)
#   x <- sampleRegular(x, maxpixels, asRaster=TRUE)
#   coords <- xyFromCell(x, seq_len(ncell(x)))
#   ## Extract values
#   dat <- stack(as.data.frame(getValues(x)))
#   names(dat) <- c('value', 'variable')
#   
#   dat <- cbind(coords, dat)
# }

# FBFS_pixel <-brick(query_set_stack_class[["pixel_is_FBFS"]],
#                    query_set_stack_entropy[["pixel_is_FBFS"]])

FBFS_pixel_class <-query_set_stack_class[["pixel_is_FBFS"]]
FBFS_pixel_entrophy <-query_set_stack_entropy[["pixel_is_FBFS"]]
ficher <- 'output_files/Kisumu_FBFS_pixel_class.grd'
if(!file.exists(ficher)){
  writeRaster(FBFS_pixel_class, filename = ficher)
}
ficher <- 'output_files/Kisumu_FBFS_pixel_entrophy.grd'
if(!file.exists(ficher)){
  writeRaster(FBFS_pixel_entrophy, filename = ficher)
}


# Tigray_coverge <- query_set_stack_class[["pixel_is_FBFS"]]
Tigray_coverge <- get_coverages(FBFS_pixel_class, Tigray)

# p1 <- sapply(list(Posterior = query_set_stack_class, Entrophy = query_set_stack_entropy), FUN = gplot_data, simplify = FALSE)
# p1 <- reshape2::melt(p1, id.vars=c( 'x','y','value','variable'))
# p1 <- p1[p1$variable != 'pixel_is_FBFS', ]
# 

p1 <- dropLayer(query_set_stack_class, 'pixel_is_FBFS')
p2 <- dropLayer(query_set_stack_entropy, 'pixel_is_FBFS')

# labeller1 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
#               "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
#               "Vegetation variation \ncaused by flood")
# 
# names(labeller1) <- c(as.character(unique(p1$variable)), as.character(unique(p1$L1)))
# labeller1 <- as_labeller(labeller1)
midpoint <- median(p1[], rm.na = TRUE)
p1 <- rasterVis::gplot(p1, maxpixels=ncell(p1))+
  geom_raster(aes(fill = value)) +
  # facet_grid(L1~variable, labeller = labeller1)+geom_raster()+
    facet_wrap(~ variable, nrow = 1, labeller = labeller1) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+ 
  my_theme +
  theme(axis.text = element_text(size = 8),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 8, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 8),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), breaks = scales::pretty_breaks(n=4))+
  labs(subtitle='Posterior maps')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.35, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))  



p1 <- gTree(children = gList(grid.arrange(p1), gb))

midpoint <- median(p2[], rm.na = TRUE)
p2 <- rasterVis::gplot(p2, maxpixels=ncell(p2))+
  geom_raster(aes(fill = value)) +
  # facet_grid(L1~variable, labeller = labeller1)+geom_raster()+
    facet_wrap(~ variable, nrow = 1, labeller = labeller2) +
  # scale_fill_gradientn(colours=rev(terrain.colors(255)))+
  scale_fill_gradient2(low = col[6], mid = col[3], high = col[1],
                       midpoint = midpoint)+
 theme_minimal()+
  #my_line_theme+ 
  my_theme +
  theme(axis.text = element_text(size = 8),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 8, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 8),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), breaks = scales::pretty_breaks(n=4))+
  labs(subtitle='Uncertainity maps')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.35, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))  

p2 <- gTree(children = gList(grid.arrange(p2), gb))

p1 <- arrangeGrob(p0, 
                  p1,
                  p2,
                  nrow=3,
                  # widths = unit(c(7.54, 7.54, 7.54), c("in", "in", "in")),
                  heights = unit(c(2.5, 1.25, 1.25), c("in", "in", "in"))
                  
)


p1 <- list(p1)
p1$top = grid::textGrob("Kisumu County, Kenya: MODIS 2014-01-01 / 2016-12-26.",
                             x=0, hjust=0, vjust = 0.5,
                             gp = gpar(fontfamily='serif',fontsize=14,fontface="bold", col="black"))
p1$ncol <- 1

p1 <- do.call(grid.arrange, p1)
p1 <- gTree(children = gList(grid.arrange(p1), gb))
```

```{r fig5 Kisumu,echo=FALSE,fig.width=7.54,fig.height=5.25,dpi=300,fig.cap="Prior, posterior, and uncertainity maps of differents spatial data used to feed the BNs for mapping FBFS in Kisumu county, Kenya."}
grid.draw(p1)
```

```{r fig5 Kisumu export,echo=FALSE,include=FALSE}
ggsave(plot=p1, device = 'png', filename = "figures/Kisumu_prior_posterior_uncertainity_plot.png", dpi = 300, width=7.54, height = 5.25)
```

The importance of vegetation infestation in the Kenyan part of Lake Victoria has been reported in previous studies [@Cavalli_et_al_2009]. The high vegetation along with its low sensitivity to water variation in littoral zone can be explained by the permanence of water. Gikuma-Njuru et al. [-@Gikuma-Njuru_et_al_2005] reported higher Chlorophyll concentrations in the  littoral compared to the pelagic zones due to nutrients additions from tributaries [@World_Bank_1996].  The highest vegetation variability associated with the lake water may be explained by a sequence of proliferation and decline of aquatic plants (e.g. algae) at certain periods of the year. Another explanation could be the periods of active mixing resulting in water-vegetation mixtures [@Cavalli_et_al_2009; @Gikuma-Njuru_et_al_2005]. The confusion with regards to the spectral response of open water and forest is a testimonies of uncertainty sources. Care must be taken when dealing with remote sensing data to avoid such errors, particularly in studies dealing with water and vegetation [see @Cavalli_et_al_2009]. In general, water indices are sensitive to vegetation liquid water [see @Boschetti_et_al_2014].

## Posterior spatial distribution of the spatial data node states {#II5}

The output maps from the [BNs](https://en.wikipedia.org/wiki/Bayesian_network) model are shown in Figure \@ref(fig:fig12) and their respective uncertainties in Figure \@ref(fig:fig13). The suitable topography for FBFS, resulting from the interaction between the slope and flow accumulation nodes, is generally high in area having high flow accumulation which are not necessarily water body. The soil suitability (suitable soils node) is even more misleading showing forests and open waters as having highest suitable in soil for FBFS. Intuitively, permanently waterlogged areas may not be suitable for agriculture. Characteristic vegetation, in contrast, is rather accurate excluding most open waters and forests from typical vegetation for FBFS.  Interestingly, the pattern of the characteristic vegetation is depicted with most vegetation exposed to waterlogging close to open water. Clearly, there is a change in the characteristic vegetation at a certain distance from Lake Victoria with the closed area to the Lake showing vegetation exposed to waterlogging and most of the areas near rivers Mogus, Awach, Sondu Miriu, Nyando and Kibos exhibiting hydrated vegetation.

<!-- ```{r fig12, echo=FALSE, out.width = '100%', fig.cap="Posterior FBFS maps and other important FBFS metrics in Kisumu county, Kenya."} -->
<!-- knitr::include_graphics("figures/Mapping_FBFS_posterior_maps.png") -->
<!-- ``` -->

Important changes were introduced from the prior to the posterior maps of water present node. One important change is related to the appearance of a sort-of islands or at least a tendency to drying in certain parts of the Lake shores leading to the conclusion that water may be not be present all the yearlong in that area. Another important change is the increase in the areas where water can be expected on the ground. Probably due to vegetation liquid water, most forests have shown important water presence. The variable temporal variation in vegetation index ranked higher on forests and open waters with most central areas resulting in the lowest. This high vegetation variability over the Lake support the idea of the sequential increase / decrease of aquatic vegetation at certain period of the year (see section \@ref(II4)), particularly looking at the map of the node vegetation variation caused by flood. The highest chance of flood is recorded near the lake shore and river Nyando, but most floodplains scored high values. As expected, vegetation variation attributed to flood (vegetation variation caused by flood node) seems to be positively correlated with flow accumulation and suitable topography for FBFS. In general, most of the posterior maps are not conclusive enough to be considered as standalone decision support with regards the potential area for FBFS. The target map (pixel is FBFS) seems to also be strongly correlated with flow accumulation and suitable topography and support the idea of vegetation presence inside the Lake which certain parts appears among the very likely areas for FBFS. As expected, most riverbanks are detected as having high potential for FBFS; which potential declines with distance.

<!-- ```{r fig13, echo=FALSE, out.width = '100%', fig.cap="Spatially explicit uncertainity maps derived as part of FBFS mapping in Kisumu county, Kenya."} -->
<!-- knitr::include_graphics("figures/Mapping_FBFS_uncertainity_maps.png") -->
<!-- ``` -->

The spatial explicit uncertainty (Figure \@ref(fig:fig13)), expressed as shannon entropy, revealed that the lowest level of uncertainty seems to be achieved with the suitable topography. This may be explained by the simplicity of the causality specified in this node but also the relative accuracy of the data (radar versus optical sensor) used to feed the parents nodes (slope and flow accumulation). Regarding this node, the highest uncertainty spot seems to be located around high flow accumulation areas where water is potentially present, but the topography is not necessarily flat. As stated earlier, the node suitable soils might be misleading, and this can be seen in the uncertainty map where most areas having either relatively low vegetation or water ranked amongst the highest uncertainty spots. Most open water seems to have the lowest uncertainty with regards to characteristic vegetation node contrary to water presence. The uncertainty map related to temporal variation in vegetation index has captured the drying spot inside the Lake as discussed earlier. High uncertainty regarding flood seems be ubiquitous and this seems to be propagated into the node vegetation variation caused by flood. Coming to the target node, there is high uncertainty on most pixels associated with open water. As it can be seen, the water in the Lake is associated with the highest level of uncertainty supporting the ideas that these areas are not suitable. In a nutshell, the posterior maps are to be used with consideration to the associated uncertainty maps.

## Case study: Application to Tigray region of Ethiopia 


```{r Tigray data fetching and gap filling, include = FALSE, echo = FALSE, cache = FALSE}

rm(list=setdiff(ls(), c('my_theme', "gb", 'Kisumu', 'Tigray', 'get_coverages', 'col')))
gc()

# beginCluster(n=10)

f <- function(x) {
  x[x < -10000] <- NA
  x[x > 10000] <- NA
  chillR::interpolate_gaps(x)$interp
}

ndvi_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDVI/MOD09A1_NDVI_1_2014_361_2016_RData.RData"
ndvi_ts <-get(load(ndvi_ts))
noms <- getZ(ndvi_ts)
# ndvi_ts <- calc(ndvi_ts, fun = f)
ndvi_ts <- clusterR(x=ndvi_ts, fun=calc, args=list(fun=f))
names(ndvi_ts) <- noms

GAO_NDWI_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/Gao NDWI/MOD09A1_Gao NDWI_1_2014_361_2016_RData.RData"
GAO_NDWI_ts <-get(load(GAO_NDWI_ts))
noms <- getZ(GAO_NDWI_ts)
# GAO_NDWI_ts <- calc(GAO_NDWI_ts, fun = f)
GAO_NDWI_ts <- clusterR(x=GAO_NDWI_ts, fun=calc, args=list(fun=f))
names(GAO_NDWI_ts) <- noms


mcfeeters_NDMI_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/Mcfeeters_NDWI/MOD09A1_Mcfeeters_NDWI_1_2014_361_2016_RData.RData"
mcfeeters_NDMI_ts <-get(load(mcfeeters_NDMI_ts))
noms <- getZ(mcfeeters_NDMI_ts)
# mcfeeters_NDMI_ts <- calc(mcfeeters_NDMI_ts, fun = f)
mcfeeters_NDMI_ts <- clusterR(x=mcfeeters_NDMI_ts, fun=calc, args=list(fun=f))
names(mcfeeters_NDMI_ts) <- noms


Boschetti_NDFI_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDFI/MOD09A1_NDFI_1_2014_361_2016_RData.RData"
Boschetti_NDFI_ts <-get(load(Boschetti_NDFI_ts))
noms <- getZ(Boschetti_NDFI_ts)
# Boschetti_NDFI_ts <- calc(Boschetti_NDFI_ts, fun = f)
Boschetti_NDFI_ts <- clusterR(x=Boschetti_NDFI_ts, fun=calc, args=list(fun=f))
names(Boschetti_NDFI_ts) <- noms

ndii6_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDII6/MOD09A1_NDII6_1_2014_361_2016_RData.RData"
ndii6_ts <-get(load(ndii6_ts))
noms <- getZ(ndii6_ts)
# ndii6_ts <- calc(ndii6_ts, fun = f)
ndii6_ts <- clusterR(x=ndii6_ts, fun=calc, args=list(fun=f))
names(ndii6_ts) <- noms

ndii7_ts <- "data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/NDII7/MOD09A1_NDII7_1_2014_361_2016_RData.RData"
ndii7_ts <-get(load(ndii7_ts))
noms <- getZ(ndii7_ts)
# ndii7_ts <- calc(ndii7_ts, fun = f)
ndii7_ts <- clusterR(x=ndii7_ts, fun=calc, args=list(fun=f))
names(ndii7_ts) <- noms


p_tools <-"data_files/ndsi/Tigray/Surf_Ref_8Days_500m_v6/Time_Series/RData/Terra/QA_bits/MOD09A1_QA_bits_1_2014_361_2016_RData.RData"
p_tools <-get(load(p_tools))

# p_tools <- calc(p_tools, fun = function(x) {
#   out <- length(x[x==0])/length(x)
#   ifelse(out==1, 1, 0)
# })
p_tools <- clusterR(x=p_tools, fun=calc, args=list(fun = function(x) {
  out <- length(x[x==0])/length(x)
  ifelse(out==1, 1, 0)
}))

# endCluster()
```

```{r spatial data Tigray nodes,echo=FALSE,include=FALSE}
##  Soil water content node: soil_water_content ####
# this is somehow removing the water in vegetation and water on the ground (flood) from a mixture of water in both 
# vegetation and soil. so, we get an idea of the water in soil
# soil_water_content <- (calc(ndii7_ts, function(i) sum(i, na.rm = T))+
#                          calc(ndii6_ts, function(i) sum(i, na.rm = T))+
#                          2*calc(Boschetti_NDFI_ts, function(i) sum(i, na.rm = T))-
#                          2*calc(ndvi_ts, function(i) sum(i, na.rm = T)))/2
# 
ficher <- 'output_files/Tigray_soil_water_content.grd'
if(!file.exists(ficher)){
soil_water_content <- calc(ndii7_ts, function(i) sum(i, na.rm = T))
p1 <- calc(ndii6_ts, function(i) sum(i, na.rm = T))
p2 <- calc(Boschetti_NDFI_ts, function(i) 2*(sum(i, na.rm = T)))
p3 <- calc(ndvi_ts, function(i) -2*(sum(i, na.rm = T)))
soil_water_content <- brick(soil_water_content, p1, p2, p3)
soil_water_content <- calc(soil_water_content, function(i) sum(i, na.rm = T)/2, 
                           filename = ficher)
rm(p1,p2,p3)
# writeRaster(soil_water_content, filename = ficher)
} else {
  soil_water_content <- raster(ficher)
}

soil_water_content <- discretize_raster(soil_water_content, split_IQR = FALSE) # split_IQR was TRUE in Kisumu

##  Exposure to wetness node:exposure2wetness ####
## this is the total flood recorded over the time series.
ficher <- 'output_files/Tigray_exposure2wetness.grd'
if(!file.exists(ficher)){
exposure2wetness <- calc(Boschetti_NDFI_ts, function(x) sum(x, na.rm = T), 
                         filename = ficher)
} else {
  exposure2wetness <- raster(ficher)
}
# plot(exposure2wetness)
exposure2wetness <- discretize_raster(exposure2wetness,split_IQR = FALSE) # split_IQR was TRUE in Kisumu

## Sensitivity to flood node: sensitivity2flood ####
# This is just the absolute standard error, somewhat how fast the flood index is changing throughout the time. 
ficher <- 'output_files/Tigray_sensitivity2flood.grd'
if(!file.exists(ficher)){
sensitivity2flood <- calc(Boschetti_NDFI_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)),
                          filename = ficher)
} else {
  sensitivity2flood <- raster(ficher)
}
sensitivity2flood <- discretize_raster(sensitivity2flood, split_IQR = TRUE)

##  Vegetation sensitivity to water node: veg_sensitivity2water ####
# similar to  Sensitivity to flood node 
# vegetation/soil water using the ndii6
# >>> ndii6_var <- calc(ndii6_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation/soil water using the ndii7
# >>> ndii7_var <- calc(ndii7_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation density using ndvi
# >>> veg_variability <- calc(ndvi_ts, function(i) abs(sd(i, na.rm = T)/abs(mean(i, na.rm = T))))
# vegetation sensitivity to water adding the water content (in soil/vegetation) from SWIR2 and SWIR3 
# and dividing 2*ndvi. therefore this is just the ratio water-vegetation. 2*ndvi because of the use of the 
# 2 SWIR chanels.
# veg_sensitivity2water_var <- (calc(ndii6_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)))+
#                                 calc(ndii7_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T))))/
#   (2*calc(ndvi_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T))))
ficher <- 'output_files/Tigray_veg_sensitivity2water_var.grd'
if(!file.exists(ficher)){
  # veg_sensitivity2water_var <- calc(ndii6_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)))
veg_sensitivity2water_var <- clusterR(x = ndii6_ts, fun = calc, args = list(fun=function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T))))

# p1 <- calc(ndii7_ts, function(i) abs(sd(i, na.rm = T)/mean(i, na.rm = T)))
p1 <- clusterR(x=ndii7_ts, fun=calc, args = list(fun=abs(sd(i, na.rm = T)/mean(i, na.rm = T))))

# p2 <- calc(ndvi_ts, function(i) 2*abs(sd(i, na.rm = T)/mean(i, na.rm = T)))
p2 <- clusterR(ndvi_ts, fun=calc, args = list(fun=function(i) 2*abs(sd(i, na.rm = T)/mean(i, na.rm = T))))

veg_sensitivity2water_var <- brick(veg_sensitivity2water_var, p1, p2)

# veg_sensitivity2water_var <- calc(veg_sensitivity2water_var, function(x) (x[1] + x[2])/x[3], 
#                                   filename = ficher)
veg_sensitivity2water_var <- clusterR(veg_sensitivity2water_var, fun=calc, args = list(fun=function(x) (x[1] + x[2])/x[3]), filename = ficher)
rm(p1, p2)
} else {
  veg_sensitivity2water_var <- raster(ficher)
}
veg_sensitivity2water_var <- discretize_raster(veg_sensitivity2water_var, split_IQR = TRUE)

# Tigray <-readOGR('data_files/shapefiles/Tigray.shp')

ficher <- 'data_files/dem/Tigray/Tigray_dem_mosaic_cropped_flow_acc.tif'

if(!file.exists(ficher)){

RTauDEM::getDEM(shp=Tigray, path = "data_files/dem/Tigray")

.wd <- getwd()
setwd('data_files/dem/Tigray')
dem <- list.files(pattern = '.tif')
dem <- dem[grepl(pattern = 'srtm', dem)]
dem <- paste(dem, collapse = ' ')
cmd <- paste("gdalbuildvrt Tigray_dem_mosaic.vrt", dem)
system (cmd)
dem <- 'Tigray_dem_mosaic_cropped.tif'
cmd <- paste(c('-te', as.numeric(as.matrix(extent(ndvi_ts)))), collapse = ' ')
cmd <- paste('gdalwarp -of GTiff  -overwrite', cmd, 'Tigray_dem_mosaic.vrt', dem)
system(cmd)

resample(raster('Tigray_dem_mosaic_cropped.tif'), ndvi_ts, filename = 'Tigray_dem_mosaic_cropped_resampled.tif', overwrite=TRUE)

# Pitremove(fun = 'pitremove', demfile = dem)
system('mpiexec -n 8 pitremove -z Tigray_dem_mosaic_cropped_resampled.tif -fel Tigray_dem_mosaic_cropped_pitremoved.tif')

system ('mpiexec -n 8 d8flowdir -p Tigray_dem_mosaic_cropped_flow_dir.tif -sd8 Tigray_dem_mosaic_cropped_slope.tif -fel Tigray_dem_mosaic_cropped_pitremoved.tif')
system ('mpiexec -n 8 aread8 -p Tigray_dem_mosaic_cropped_flow_dir.tif -ad8 Tigray_dem_mosaic_cropped_flow_acc.tif -nc')
# system ('mpiexec -n 8 areadinf -ang Kisumu_dem_mosaic_cropped_flow_dir.tif -sca Kisumu_dem_mosaic_cropped_flow_acc.tif -nc')
ficher <- 'Tigray_dem_mosaic_cropped_flow_acc.tif'
f_acc <- raster(ficher)
setwd(.wd)
} else {
  f_acc <- raster(ficher)
}


# downgrading the resolution the modis resolution
# f_acc <- resample(f_acc, ndvi_ts)
f_acc <- discretize_raster(f_acc, split_IQR = FALSE)
f_acc <- focal (f_acc, w=matrix(1,9,9), fun=modal, 
                na.rm=TRUE, NAonly=TRUE, pad=TRUE)

slope <- raster('data_files/dem/Tigray/Tigray_dem_mosaic_cropped_slope.tif')
slope <- calc(x = slope, fun = function(x) atan(x)*180/pi)
slope <- resample(slope, ndvi_ts)
slope <- discretize_raster(slope, split_IQR = TRUE)
slope <- focal (slope, w=matrix(1,9,9), fun=modal, 
                na.rm=TRUE, NAonly=TRUE, pad=TRUE)

## Temporal variation vegetation indices ####

## we calculated the lenght of the growing season from the onset and cessation dates
## interpolate relative to a mean surface and use the anomalies

# beginCluster(n=10
ficher <- 'output_files/Tigray_tempo_var_vi.grd'

if(!file.exists(ficher)){
ndvi_var <- par_stack_season_dates(ndvi_ts, valid_range = c(-10000, 10000), filename = 'output_files/Tigray_lgs.grd', overwrite=TRUE)
# endCluster()

## getting the first rainy season which correspond to layer 1 and 2 
first_season <- ndvi_var [[2]] - ndvi_var[[1]]
second_season <- ndvi_var [[4]] - ndvi_var[[3]]
rm(ndvi_var)

# wndow <- matrix(1,3,3)
# fun: a function to be used by focal
f <- function(x){
  out <- modal(x, na.rm = TRUE, ties = 'NA') # getting the modal values
  out <- ifelse(length(out) == 1, out, NA) # if only one recode it to the most likely in the window else assign NA to it
  out
}

first_season <- focal (first_season, w=matrix(1,3,3), fun=f, na.rm=FALSE, NAonly=TRUE, pad=TRUE)

## interpolating using Thin plate spline regression
# making an interpolation surface of 5 cells arround, something like 5*500=2500 m 
interp_surf_first_season <- aggregate(first_season, 4)
## getting the xy coords for builing the interpolation model
# xy <- data.frame(xyFromCell(interp_surf_first_season, 1:ncell(interp_surf_first_season)))
xy <- sampleRandom(interp_surf_first_season, xy = TRUE, size = 1000)
# ## getting the pixel values for builing the interpolation model
# v <- getValues(interp_surf_first_season)
## Thin plate spline model with fields package
# tps <- Tps(xy, v, lon.lat=T)
tps <- Tps(xy[, 1:2], xy[, 3], lon.lat=T)

p <- raster(first_season)
# use model to predict values at all locations
first_season_interp <- interpolate(p, tps)
# plot(first_season_interp)
# removing the local means from each pixel to get the anomalies.
first_season_SE <- first_season - first_season_interp
# plot(first_season_SE)
rm(first_season, first_season_interp, p, tps, xy, interp_surf_first_season)

second_season <- focal (second_season, w=matrix(1,3,3), fun=f, na.rm=FALSE, NAonly=TRUE, pad=TRUE)

## interpolating using Thin plate spline regression
# making an interpolation surface of 5 cells arround, something like 5*500=2500 m 
interp_surf_second_season <- aggregate(second_season, 4)
# ## getting the xy coords for builing the interpolation model
# xy <- data.frame(xyFromCell(interp_surf_second_season, 1:ncell(interp_surf_second_season)))
xy <- sampleRandom(interp_surf_second_season, xy = TRUE, size = 1000)
# ## getting the pixel values for builing the interpolation model
# v <- getValues(interp_surf_second_season)
## Thin plate spline model with fields package
# tps <- Tps(xy, v, lon.lat=T)
tps <- Tps(xy[, 1:2], xy[, 3], lon.lat=T)
p <- raster(second_season)
# use model to predict values at all locations
second_season_interp <- interpolate(p, tps)
# plot(first_season_interp)
# removing the local means from each pixel to get the anomalies.
second_season_SE <- second_season - second_season_interp
# plot(second_season_SE)

ndvi_var <- first_season_SE + second_season_SE
rm(first_season_SE, second_season_SE)
# fill NA with the most likely value across a 9 by 9 moving window.
ndvi_var <- focal (ndvi_var, w=matrix(1,9,9), fun=function(x, ...) mean(x, na.rm = TRUE), 
                   na.rm=TRUE, NAonly=TRUE, pad=TRUE)
# plot(ndvi_var)
tempo_var_vi <- discretize_raster(ndvi_var, split_IQR = TRUE)
# plot(tempo_var_vi)
rm(ndvi_var, second_season, second_season_interp, p, tps, xy, interp_surf_second_season,
   dem, cmd)
writeRaster(tempo_var_vi, filename = ficher)
} else {
  tempo_var_vi <- raster(ficher)
}
## flood_bgs: flood at the beginning of the rainy season #####
ficher <- 'output_files/Tigray_flood_bgs.grd'
if(!file.exists(ficher)){
  
  # a function for extracting layers in the time series in the near beginning of the rainy season
  extract_Zlayer <- function(r_stack,
                             # date_ranges = list (c("2014-02-01", "2014-04-30"), c("2015-02-01", "2015-04-30"), c("2016-02-01", "2016-04-30"),
                             #                     c("2014-07-01", "2014-09-30"), c("2015-07-01", "2015-09-30"), c("2016-07-01", "2016-09-30")),
                             date_ranges = list (c("2014-03-01", "2014-04-30"), c("2015-03-01", "2015-04-30"), c("2016-03-01", "2016-04-30"),
                                                 c("2014-08-01", "2014-09-30"), c("2015-08-01", "2015-09-30"), c("2016-08-01", "2016-09-30")),
                             valid_range = c(-1, 1)){
    # dates <- getZ(r_stack)
    dates <-  as.Date(substring(names(r_stack), 2), format = "%Y.%m.%d")
    sel_dates <- unlist(lapply(date_ranges, function(x){
      which(dates >= as.Date(x[1]) & dates <= as.Date(x[2]))
    }))
    out<- r_stack[[sel_dates]]
    # out <- setZ(out, NULL)
    # out<- rts::rts (out,dates[sel_dates])
    return(out)
  }
  
  flood_bgs <- extract_Zlayer(Boschetti_NDFI_ts)
  flood_bgs <- compile_pixel_states(flood_bgs, split_IQR = FALSE, inparallel = 10)
  flood_bgs <- flood_bgs$output
  writeRaster(flood_bgs, filename = ficher)
} else {
  flood_bgs <- raster(ficher)
}

ficher <- 'output_files/Tigray_water_prznt.grd'

if(!file.exists(ficher)){
water_prznt <- compile_pixel_states(Boschetti_NDFI_ts, split_IQR = FALSE)
water_prznt <- water_prznt$output
writeRaster(water_prznt, filename = ficher)
} else {
  water_prznt <- raster(ficher)
}

```

```{r Bnspatial Tigray,echo=FALSE,include=FALSE}
## combining the spatial data nodes into a list ####

spatialData <- c(f_acc,
                 slope, 
                 p_tools, 
                 water_prznt, 
                 flood_bgs, 
                 tempo_var_vi,
                 soil_water_content,
                 exposure2wetness,
                 sensitivity2flood,
                 veg_sensitivity2water_var
)


## Loading the Bayesian network ####
source("source_files/BNs.R")

## specifying the classes and their boundaries for each spatial data nodes ####
names_spatialData <- c('f_acc',
                       'slope', 
                       'p_tools', 
                       'water_prznt', 
                       'flood_bgs', 
                       'tempo_var_vi',
                       'soil_water_content',
                       'exposure2wetness',
                       'sensitivity2flood',
                       'veg_sensitivity2water_var')

intervals <- setClasses(c("f_acc",
                          "slope",
                          "p_tools",
                          "water_prznt", 
                          "flood_bgs",  
                          "tempo_var_vi",
                          "soil_water_content",
                          "exposure2wetness",
                          "sensitivity2flood",
                          "veg_sensitivity2water_var"), 
                        list(f_acc_node$levels,
                             slope_node$levels, 
                             p_tools_node$levels, 
                             water_prznt_node$levels, 
                             flood_bgs_node$levels, 
                             tempo_var_vi_node$levels,
                             soil_water_content_node$levels,
                             exposure2wetness_node$levels,
                             sensitivity2flood_node$levels,
                             veg_sensitivity2water_var_node$levels),
                        list(sort(unique(f_acc[])),
                             sort(unique(slope[])),
                             sort(unique(p_tools[])),
                             sort(unique(water_prznt[])),
                             sort(unique(flood_bgs[])),
                             
                             sort(unique(tempo_var_vi[])),
                             sort(unique(soil_water_content[])),
                             sort(unique(exposure2wetness[])),
                             sort(unique(sensitivity2flood[])),
                             sort(unique(veg_sensitivity2water_var[])))
)

## linking the network with the spatial data ####
spatialDataList <- linkMultiple(spatialData, network, intervals)

# # ## removing objects that are no longer needed ####
rm(list=setdiff(ls(), c("spatialData", 'spatialDataList', "network", "network_bn_fit", 'my_theme', "gb",
                        'intervals','Kisumu', 'get_coverages', 'Tigray', 'col')))
gc()

## Query the bn and making some maps ####
## please adjust the number of cores par parallel processus
you_have_only_one_core_left <- parallel::detectCores()-30

query_set_names <- nodes(network_bn_fit)[(!(nodes(network_bn_fit) %in% root.nodes(network_bn_fit)))]

query_set <- sapply(query_set_names, function (i){
  # obj <- paste0(i, '_', 'query')
  assign(paste0(i, '_', 'query'), bnspatial(network = network, target = i, spatialData = spatialData, lookup = intervals, inparallel=you_have_only_one_core_left),
         envir=.GlobalEnv)

}, simplify = FALSE, USE.NAMES = TRUE)

# query_set <- bnspatial(network = network, target = 'pixel_is_FBFS', spatialData = spatialData, lookup = intervals, inparallel=you_have_only_one_core_left)


# query_set_stack <- unlist(query_set)
query_set_stack_class <- sapply(query_set, '[[', 1)
names_query_set_stack_class <- names(query_set_stack_class)
names(query_set_stack_class) <- NULL
query_set_stack_class <- do.call('brick', query_set_stack_class)
names (query_set_stack_class) <- names_query_set_stack_class

query_set_stack_entropy <- sapply(query_set, '[[', 2)
names_query_set_stack_entropy <- names(query_set_stack_entropy)
names(query_set_stack_entropy) <- NULL
query_set_stack_entropy <- do.call('brick', query_set_stack_entropy)
names (query_set_stack_entropy) <- names_query_set_stack_entropy

spatialData <- sapply(spatialDataList, '[[', 4)
names_spatialData <- names(spatialData)
names(spatialData) <- NULL
spatialData <- do.call('brick', spatialData)
names(spatialData)<- names_spatialData
```

```{r Bnspatial plot Tigray,echo=FALSE,include=FALSE}
# making more intuitive  labels for ggplot facets
labeller0 <- c("Flow accumulation", "Slope", "Power of tools", "Water present", "Flood at the beginning\nof the rainy season", 
               "Temporal variation\nin vegetation index", "Soil water content", "Exposure to wetness", "Sensitivity to flood",
               "Vegetation sensitivity\n to water variation")
names(labeller0) <- names_spatialData
labeller0 = as_labeller(labeller0)

labeller1 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
              "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
              "Vegetation variation \ncaused by flood", 
              "Pixel is FBFS")
names(labeller1) <- names_query_set_stack_class
labeller1 = as_labeller(labeller1)

labeller2 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
              "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
              "Vegetation variation \ncaused by flood", 
              "Pixel is FBFS")
names(labeller2) <- names_query_set_stack_entropy
labeller2 = as_labeller(labeller2)


# # ggploting the rasters

f <- function(decimals=0){
  # return a function responpsible for formatting the 
  # axis labels with a given number of decimals 
  function(x) as.character(round(x,decimals))
}


# col= c("#1B9E77", "#66A61E", "#7570B3", "#D95F02", "#E6AB02", "#E7298A")
p0 <- rasterVis::gplot(spatialData, maxpixels=ncell(spatialData))+
  geom_raster(aes(fill = value)) +
  facet_wrap(~ variable, ncol = 5, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+ 
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 10, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 8),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  labs(subtitle='Prior spatial data nodes')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))  

p0 <- gTree(children = gList(grid.arrange(p0), gb))


# gplot_data <- function(x, maxpixels=ncell(x), ...){
#   nl <- nlayers(x)
#   x <- sampleRegular(x, maxpixels, asRaster=TRUE)
#   coords <- xyFromCell(x, seq_len(ncell(x)))
#   ## Extract values
#   dat <- stack(as.data.frame(getValues(x)))
#   names(dat) <- c('value', 'variable')
#   
#   dat <- cbind(coords, dat)
# }

# FBFS_pixel <-brick(query_set_stack_class[["pixel_is_FBFS"]],
#                    query_set_stack_entropy[["pixel_is_FBFS"]])

FBFS_pixel_class <-query_set_stack_class[["pixel_is_FBFS"]]

ficher <- 'output_files/Tigray_FBFS_pixel_class.grd'
if(!file.exists(ficher)){
  writeRaster(FBFS_pixel_class, filename = ficher)
}

FBFS_pixel_entrophy <-query_set_stack_entropy[["pixel_is_FBFS"]]

ficher <- 'output_files/Tigray_FBFS_pixel_entrophy.grd'
if(!file.exists(ficher)){
  writeRaster(FBFS_pixel_entrophy, filename = ficher)
}


# Tigray_coverge <- query_set_stack_class[["pixel_is_FBFS"]]
Tigray_coverge <- get_coverages(FBFS_pixel_class, Tigray)

# p1 <- sapply(list(Posterior = query_set_stack_class, Entrophy = query_set_stack_entropy), FUN = gplot_data, simplify = FALSE)
# p1 <- reshape2::melt(p1, id.vars=c( 'x','y','value','variable'))
# p1 <- p1[p1$variable != 'pixel_is_FBFS', ]
# 

p1 <- dropLayer(query_set_stack_class, 'pixel_is_FBFS')
p2 <- dropLayer(query_set_stack_entropy, 'pixel_is_FBFS')

# labeller1 = c("Suitable topography", "Suitable soils", "Characteristic \nvegetation", 
#               "Water present", "Temporal variation \nin vegetation index", "Flooded \nat some points", 
#               "Vegetation variation \ncaused by flood")
# 
# names(labeller1) <- c(as.character(unique(p1$variable)), as.character(unique(p1$L1)))
# labeller1 <- as_labeller(labeller1)
midpoint <- median(p1[], rm.na = TRUE)
p1 <- rasterVis::gplot(p1, maxpixels=ncell(p1))+
  geom_raster(aes(fill = value)) +
  # facet_grid(L1~variable, labeller = labeller1)+geom_raster()+
    facet_wrap(~ variable, nrow = 1, labeller = labeller1) +
  scale_fill_gradientn(colours=col)+
    # scale_fill_gradient2(low = '#F5DEB3', mid = '#FFEFD5', high = "#AFEEEE",
    #                    midpoint = midpoint)+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  my_theme+  labs(subtitle='Posterior maps')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0, unit = 'cm'))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  # theme(legend.position = 'none')+
  # theme(axis.text = element_text(size = 12))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))+
  theme(strip.text = element_text(size = 8))


p1 <- gTree(children = gList(grid.arrange(p1), gb))

midpoint <- median(p2[], rm.na = TRUE)
p2 <- rasterVis::gplot(p2, maxpixels=ncell(p2))+
  geom_raster(aes(fill = value)) +
  # facet_grid(L1~variable, labeller = labeller1)+geom_raster()+
    facet_wrap(~ variable, nrow = 1, labeller = labeller2) +
  # scale_fill_gradientn(colours=rev(terrain.colors(255)))+
  scale_fill_gradient2(low = col[6], mid = col[3], high = col[1],
                       midpoint = midpoint)+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=4), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  my_theme+ 
  labs(subtitle='Uncertainty maps')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=0, b=0, unit = 'cm'))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  # theme(legend.position = 'none')+
  # theme(axis.text = element_text(size = 12))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))+
  theme(strip.text = element_text(size = 8))

p2 <- gTree(children = gList(grid.arrange(p2), gb))

p1 <- arrangeGrob(p0, 
                  p1,
                  p2,
                  nrow=3,
                  # widths = unit(c(7.54, 7.54, 7.54), c("in", "in", "in")),
                  heights = unit(c(7/2.15, 7/4.4, 7/4.4), c("in", "in", "in"))
                  
)


p1 <- list(p1)
p1$top = grid::textGrob("Tigray region, Ethiopia: MODIS 2014-01-01 / 2016-12-26.",
                             x=0, hjust=0, vjust = 0.5,
                             gp = gpar(fontfamily='serif',fontsize=14,fontface="bold", col="black"))
p1$ncol <- 1

p1 <- do.call(grid.arrange, p1)
p1 <- gTree(children = gList(grid.arrange(p1), gb))
```

```{r fig5 Tigray,echo=FALSE,fig.width=7.54,fig.height=6.685,dpi=300,fig.cap="Prior, posterior, and uncertainity maps of differents spatial data used to feed the BNs for mapping FBFS in Tigray region, Ethiopia"}
grid.draw(p1)
```

```{r fig5 export Tigray,echo=FALSE,include=FALSE}
ggsave(plot=p1, device = 'png', filename = "figures/Tigray_prior_posterior_uncertainity_plot.png", dpi = 300, width=7.54, height = 6.68)
```

## Potential of FBFS in Kisumu and Tigray 

```{r FBFS maps Kisumu and Tigray,echo=FALSE,include=FALSE}

rm(list=setdiff(ls(), c('my_theme', "gb",'Kisumu', 'Tigray', 'col', 'f', 'get_coverages')))
gc()

Kisumu_localities <- matrix(c(34.918664, -0.173477, "Ahero",  
                       34.767892, -0.092518, "Kisumu",
                       35.073257, -0.161697, "Awasi",
                       35.200067, -0.150011, 'Muhoroni',
                       35.286275, -0.368985, 'Kericho',
                       34.971798, -0.269972, "Katito",
                       35.050748, -0.066539, 'Kibigori',
                       34.598596, -0.006742, 'Maseno')
                     , ncol=3, byrow = TRUE)

colnames(Kisumu_localities) <- c("Long", "Lat", "Place")
Kisumu_localities <- data.frame(Kisumu_localities, stringsAsFactors = FALSE)
Kisumu_localities[,1] <- as.numeric(Kisumu_localities[,1])
Kisumu_localities[,2] <- as.numeric(Kisumu_localities[,2])


Tigray_localities <- matrix(c(39.478020,  13.493353, "Mekele",  
                       39.521428,  12.507312, "Korem",
                       39.550491, 12.415558, "Alamata",
                       # 38.747275,  14.133082, 'Aksum',
                       38.747275,  14.1, 'Aksum',
                       39.460561, 14.278563, 'Adigrat',
                       # 38.893718,  14.163646, 'Adwa',
                       38.893718,  14.17, 'Adwa',
                       39.543339, 12.786711, 'Maychew'),
                     ncol=3, byrow = TRUE)
colnames(Tigray_localities) <- c("Long", "Lat", "Place")
Tigray_localities <- data.frame(Tigray_localities, stringsAsFactors = FALSE)
Tigray_localities[,1] <- as.numeric(Tigray_localities[,1])
Tigray_localities[,2] <- as.numeric(Tigray_localities[,2])

Kisumu_FBFS_pixel_class <- raster('output_files/Kisumu_FBFS_pixel_class.grd')
Kisumu_FBFS_pixel_entrophy <- raster('output_files/Kisumu_FBFS_pixel_entrophy.grd')

g <- function(x,y){
  entrophy_max <- max(Kisumu_FBFS_pixel_entrophy[], na.rm = T)
  x*(entrophy_max-y)
}
Kisumu_FBFS_pixel_overlaid <- discretize_raster(overlay(Kisumu_FBFS_pixel_class, Kisumu_FBFS_pixel_entrophy, fun=g),
                        split_IQR = T)

Tigray_FBFS_pixel_class <- raster('output_files/Tigray_FBFS_pixel_class.grd')
Tigray_FBFS_pixel_entrophy <- raster('output_files/Tigray_FBFS_pixel_entrophy.grd')

g <- function(x,y){
  entrophy_max <- max(Tigray_FBFS_pixel_entrophy[], na.rm = T)
  x*(entrophy_max-y)
}
Tigray_FBFS_pixel_overlaid <- discretize_raster(overlay(Tigray_FBFS_pixel_class, Tigray_FBFS_pixel_entrophy, fun=g),
                        split_IQR = T)
Tigray_coverge_overlaid <- get_coverages(Tigray_FBFS_pixel_overlaid, Tigray)

## FBFS raw maps ####
p01 <- rasterVis::gplot(Kisumu_FBFS_pixel_class, maxpixels=ncell(Kisumu_FBFS_pixel_class))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='FBFS Potential')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))



p01 <- p01 + 
  geom_path(data=fortify(Kisumu), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Kisumu_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Kisumu_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p3 <- gTree(children = gList(grid.arrange(p0, ncol=), gb))


p02 <- rasterVis::gplot(Tigray_FBFS_pixel_class, maxpixels=ncell(Tigray_FBFS_pixel_class))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='FBFS Potential')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))


p02 <- p02 + 
  geom_path(data=fortify(Tigray), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Tigray_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Tigray_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p0 <- gTree(children = gList(grid.arrange(p0, ncol=), gb))


p0=arrangeGrob(p01,p02,
               ncol=2,
               widths = unit(c(7.54/2.1, 7.7/3.25), c("in", "in"))
               # ,
               # heights = unit(c(2.1, 2.1), c("in", "in"))
               
)

p0 <- list(p0)
p0$top = grid::textGrob("FBFS Potential.",
                             hjust=0.5, vjust = 0.5,
                             gp = gpar(fontfamily='serif',fontsize=14,fontface="italic", col="blue"))
p0$ncol <- 1

p0 <- do.call(grid.arrange, p0)
p0 <- gTree(children = gList(grid.arrange(p0), gb))
######################################

midpoint <- median(Kisumu_FBFS_pixel_entrophy[], na.rm = TRUE)
p11 <- rasterVis::gplot(Kisumu_FBFS_pixel_entrophy, maxpixels=ncell(Kisumu_FBFS_pixel_entrophy))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  # scale_fill_gradientn(colours=rev(terrain.colors(255)))+
    scale_fill_gradient2(low = col[6], mid = col[3], high = col[1],
                       midpoint = midpoint)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='Entrophy')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))

p11 <- p11 + 
  geom_path(data=fortify(Kisumu), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Kisumu_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Kisumu_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p1 <- gTree(children = gList(grid.arrange(p1, ncol=), gb))

midpoint <- median(Tigray_FBFS_pixel_entrophy[], na.rm = TRUE)
p12 <- rasterVis::gplot(Tigray_FBFS_pixel_entrophy, maxpixels=ncell(Tigray_FBFS_pixel_entrophy))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  # scale_fill_gradientn(colours=rev(terrain.colors(255)))+
    scale_fill_gradient2(low = col[6], mid = col[3], high = col[1],
                       midpoint = midpoint)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='Entrophy')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))

p12 <- p12 + 
  geom_path(data=fortify(Tigray), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Tigray_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Tigray_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p1 <- gTree(children = gList(grid.arrange(p1, ncol=), gb))

p1=arrangeGrob(p11,p12,
               ncol=2,
               widths = unit(c(7.54/2.1, 7.7/3.25), c("in", "in"))
               # ,
               # heights = unit(c(2.1, 2.1), c("in", "in"))
               
)

p1 <- list(p1)
p1$top = grid::textGrob("Uncertainity",
                             hjust=0.5, vjust = 0.5,
                             gp = gpar(fontfamily='serif',fontsize=14,fontface="italic", col="blue"))
p1$ncol <- 1

p1 <- do.call(grid.arrange, p1)
p1 <- gTree(children = gList(grid.arrange(p1), gb))

##################################################

p21 <- rasterVis::gplot(Kisumu_FBFS_pixel_overlaid, maxpixels=ncell(Kisumu_FBFS_pixel_overlaid))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='FBFS Potential accounting for uncertainity')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))


p21 <- p21 + 
  geom_path(data=fortify(Kisumu), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Kisumu_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Kisumu_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p2 <- gTree(children = gList(grid.arrange(p2, ncol=), gb))

p22 <- rasterVis::gplot(Tigray_FBFS_pixel_overlaid, maxpixels=ncell(Tigray_FBFS_pixel_overlaid))+
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable, ncol = 1, labeller = labeller0) +
  scale_fill_gradientn(colours=col)+
  theme_minimal()+
  #my_line_theme+
  my_theme +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12, face = 'bold'),
        strip.text = element_text(size = 12, face = "bold"),
        legend.text = element_text(family = 'serif', face = 'bold', size = 7),
        plot.title = element_text(size = 14, face = 'bold', color = 'black'),
        plot.subtitle = element_text(size = 12, face = 'italic', color = 'blue'))+
  coord_equal()+
  scale_x_continuous(labels = f(1), breaks = scales::pretty_breaks(n=5), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))+
  # labs(subtitle='FBFS Potential accounting for uncertainity')+
  theme(axis.title = element_blank())+
  theme(plot.margin = margin(t=10, r=0, b=-10, l=0))+
  guides(fill=guide_colourbar(barwidth=10, barheight = 0.5, label.position="bottom"))+
  theme(strip.text.x = element_text(margin = margin(b = 0)))


p22 <- p22 + 
  geom_path(data=fortify(Tigray), aes(x=long, y= lat, group=group), colour='black',alpha=0.5)+
  geom_point(data = Tigray_localities, aes(x = Long, y = Lat), alpha=0.5)+
  geom_text(data = Tigray_localities, aes(x = Long, y = Lat, label = Place),
            hjust=1, vjust=0, size=3, alpha=0.8)

# p2 <- gTree(children = gList(grid.arrange(p2, ncol=), gb))
p2=arrangeGrob(p21,p22,
               ncol=2,
               widths = unit(c(7.54/2.1, 7.7/3.25), c("in", "in"))
               # ,
               # heights = unit(c(2.1, 2.1), c("in", "in"))
               
)

p2 <- list(p2)
p2$top = grid::textGrob("FBFS Potential accounting for uncertainity.",
                             hjust=0.5, vjust = 0.5,
                             gp = gpar(fontfamily='serif',fontsize=14,fontface="italic", col="blue"))
p2$ncol <- 1

p2 <- do.call(grid.arrange, p2)
p2 <- gTree(children = gList(grid.arrange(p2), gb))

p0 <- list(p0, p1, p2)
p0$top = grid::textGrob("Kisumu (left), Tigray (right): MODIS 2014-01-01 / 2016-12-26",
                        x=0, hjust=0, vjust = 0.5,
                        gp = gpar(fontfamily='serif',fontsize=14,fontface="bold", col="black"))
p0$bottom = grid::textGrob("Long",
                           x=0.5, hjust=0, vjust = 0.5,rot = 0,
                           gp = gpar(fontfamily='serif',fontsize=16,fontface="bold", col="black"))
p0$left = grid::textGrob("Lat",
                         rot = 90,
                         gp = gpar(fontfamily='serif',fontsize=16,fontface="bold", col="black"))

p0$ncol <- 1

p0 <- do.call(grid.arrange, p0)
p0 <- gTree(children = gList(grid.arrange(p0), gb))
```

```{r fig6,echo=FALSE,fig.width=6+0.25,fig.height= 6.88+0.5,dpi=300,fig.cap="Potential areas for FBFS and associated uncertainity in Kisumu County, Kenya and Tigray region, Ethiopia."}
grid.draw(p0)
```

```{r fig6 Kisumu export,echo=FALSE,include=FALSE}
# ggsave(plot=p0, device = 'png', filename = "figures/Kisumu_Pixel_is_FBFS_plot.png", dpi = 300, width=8.19-0.65, height = 8.16-0.65)
ggsave(plot=p0, device = 'png', filename = "figures/Kisumu_Tigray_Pixel_is_FBFS_plot.png", dpi = 300, width = 6+0.25, height = 6.88+0.5)
```

```{r table3, echo=FALSE}

Kisumu_coverge_overlaid <- get_coverages(Kisumu_FBFS_pixel_overlaid, Kisumu)
Tigray_coverge_overlaid <- get_coverages(Tigray_FBFS_pixel_overlaid, Tigray)

Kisumu_coverage_FBFS_pixel <- get_coverages(Kisumu_FBFS_pixel_class, Kisumu)
Tigray_coverage_FBFS_pixel <- get_coverages(Tigray_FBFS_pixel_class, Tigray)


coverage <- matrix(NA, nrow = 4, ncol = 5)

for (i in as.numeric(names(Kisumu_coverage_FBFS_pixel))) {
  coverage[1, i] <- Kisumu_coverage_FBFS_pixel[as.character(i)]
  # coverage[1, i] <- (coverage[1, i]*100)/(area(Kisumu)/1000000)
}

for (i in as.numeric(names(Tigray_coverage_FBFS_pixel))) {
  coverage[2, i] <- Tigray_coverage_FBFS_pixel[as.character(i)]
  # coverage[2, i] <- (coverage[2, i]*100)/(area(Kisumu)/1000000)
}

for (i in as.numeric(names(Kisumu_coverge_overlaid))) {
  coverage[3, i] <- Kisumu_coverge_overlaid[as.character(i)]
  # coverage[2, i] <- (coverage[2, i]*100)/(area(Kisumu)/1000000)
}

for (i in as.numeric(names(Tigray_coverge_overlaid))) {
  coverage[4, i] <- Tigray_coverge_overlaid[as.character(i)]
  # coverage[2, i] <- (coverage[2, i]*100)/(area(Kisumu)/1000000)
}


cov_perc <- matrix(NA, nrow = 4, ncol = 5)

for (i in as.numeric(names(Kisumu_coverage_FBFS_pixel))) {
  cov_perc[1, i] <- Kisumu_coverage_FBFS_pixel[as.character(i)]
  cov_perc[1, i] <- (cov_perc[1, i]*100)/(area(Kisumu)/1000000)
}

for (i in as.numeric(names(Tigray_coverage_FBFS_pixel))) {
  cov_perc[2, i] <- Tigray_coverage_FBFS_pixel[as.character(i)]
  cov_perc[2, i] <- (cov_perc[2, i]*100)/(area(Tigray)/1000000)
}

for (i in as.numeric(names(Kisumu_coverge_overlaid))) {
  cov_perc[3, i] <- Kisumu_coverge_overlaid[as.character(i)]
  cov_perc[3, i] <- (cov_perc[3, i]*100)/(area(Kisumu)/1000000)
}

for (i in as.numeric(names(Tigray_coverge_overlaid))) {
  cov_perc[4, i] <- Tigray_coverge_overlaid[as.character(i)]
  cov_perc[4, i] <- (cov_perc[4, i]*100)/(area(Tigray)/1000000)
}

coverage <- mapply(function(x,y) {
  if(is.na(x)){
    out <- " "
  } else {
    out <- paste(round(x, 2), "\n", "(", round(y, 2), "%", ")", sep = "")
  }
  out
  }, 
  coverage, cov_perc)

coverage <- matrix(coverage, nrow=4)
colnames(coverage) <- c('Highly unlikely', 'Unlikely', 'Possible', "Likely", "Highly likely")
rownames(coverage) <- c("Kisumu 1", "Tigray 1", "Kisumu 2", "Tigray 2")

kable(
coverage,
format="latex", booktabs=TRUE,
  caption = 'Spatial coverage of FBFS in Kisumu County, Kenya and Tigray region, Ethiopia.') %>%
  row_spec(0,bold=TRUE) %>%
  column_spec(1,bold=TRUE) %>%
  kable_styling(latex_options="scale_down")
```


\clearpage

# References
